// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tesla.proto

#ifndef PROTOBUF_tesla_2eproto__INCLUDED
#define PROTOBUF_tesla_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace tesla {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_tesla_2eproto();
void protobuf_AssignDesc_tesla_2eproto();
void protobuf_ShutdownFile_tesla_2eproto();

class Argument;
class AssertionSite;
class AutomatonDescription;
class BooleanExpr;
class Expression;
class FieldAssignment;
class FunctionEvent;
class FunctionRef;
class Identifier;
class Location;
class ManifestFile;
class Sequence;
class StructField;
class Usage;

enum AutomatonDescription_Context {
  AutomatonDescription_Context_Global = 1,
  AutomatonDescription_Context_ThreadLocal = 2
};
bool AutomatonDescription_Context_IsValid(int value);
const AutomatonDescription_Context AutomatonDescription_Context_Context_MIN = AutomatonDescription_Context_Global;
const AutomatonDescription_Context AutomatonDescription_Context_Context_MAX = AutomatonDescription_Context_ThreadLocal;
const int AutomatonDescription_Context_Context_ARRAYSIZE = AutomatonDescription_Context_Context_MAX + 1;

const ::google::protobuf::EnumDescriptor* AutomatonDescription_Context_descriptor();
inline const ::std::string& AutomatonDescription_Context_Name(AutomatonDescription_Context value) {
  return ::google::protobuf::internal::NameOfEnum(
    AutomatonDescription_Context_descriptor(), value);
}
inline bool AutomatonDescription_Context_Parse(
    const ::std::string& name, AutomatonDescription_Context* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AutomatonDescription_Context>(
    AutomatonDescription_Context_descriptor(), name, value);
}
enum Expression_Type {
  Expression_Type_BOOLEAN_EXPR = 1,
  Expression_Type_SEQUENCE = 2,
  Expression_Type_NULL_EXPR = 3,
  Expression_Type_ASSERTION_SITE = 4,
  Expression_Type_FUNCTION = 5,
  Expression_Type_FIELD_ASSIGN = 6,
  Expression_Type_SUB_AUTOMATON = 7
};
bool Expression_Type_IsValid(int value);
const Expression_Type Expression_Type_Type_MIN = Expression_Type_BOOLEAN_EXPR;
const Expression_Type Expression_Type_Type_MAX = Expression_Type_SUB_AUTOMATON;
const int Expression_Type_Type_ARRAYSIZE = Expression_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Expression_Type_descriptor();
inline const ::std::string& Expression_Type_Name(Expression_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Expression_Type_descriptor(), value);
}
inline bool Expression_Type_Parse(
    const ::std::string& name, Expression_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Expression_Type>(
    Expression_Type_descriptor(), name, value);
}
enum BooleanExpr_Operation {
  BooleanExpr_Operation_BE_And = 1,
  BooleanExpr_Operation_BE_Or = 2,
  BooleanExpr_Operation_BE_Xor = 3
};
bool BooleanExpr_Operation_IsValid(int value);
const BooleanExpr_Operation BooleanExpr_Operation_Operation_MIN = BooleanExpr_Operation_BE_And;
const BooleanExpr_Operation BooleanExpr_Operation_Operation_MAX = BooleanExpr_Operation_BE_Xor;
const int BooleanExpr_Operation_Operation_ARRAYSIZE = BooleanExpr_Operation_Operation_MAX + 1;

const ::google::protobuf::EnumDescriptor* BooleanExpr_Operation_descriptor();
inline const ::std::string& BooleanExpr_Operation_Name(BooleanExpr_Operation value) {
  return ::google::protobuf::internal::NameOfEnum(
    BooleanExpr_Operation_descriptor(), value);
}
inline bool BooleanExpr_Operation_Parse(
    const ::std::string& name, BooleanExpr_Operation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BooleanExpr_Operation>(
    BooleanExpr_Operation_descriptor(), name, value);
}
enum FunctionEvent_Direction {
  FunctionEvent_Direction_Entry = 1,
  FunctionEvent_Direction_Exit = 2
};
bool FunctionEvent_Direction_IsValid(int value);
const FunctionEvent_Direction FunctionEvent_Direction_Direction_MIN = FunctionEvent_Direction_Entry;
const FunctionEvent_Direction FunctionEvent_Direction_Direction_MAX = FunctionEvent_Direction_Exit;
const int FunctionEvent_Direction_Direction_ARRAYSIZE = FunctionEvent_Direction_Direction_MAX + 1;

const ::google::protobuf::EnumDescriptor* FunctionEvent_Direction_descriptor();
inline const ::std::string& FunctionEvent_Direction_Name(FunctionEvent_Direction value) {
  return ::google::protobuf::internal::NameOfEnum(
    FunctionEvent_Direction_descriptor(), value);
}
inline bool FunctionEvent_Direction_Parse(
    const ::std::string& name, FunctionEvent_Direction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FunctionEvent_Direction>(
    FunctionEvent_Direction_descriptor(), name, value);
}
enum FunctionEvent_CallContext {
  FunctionEvent_CallContext_Caller = 1,
  FunctionEvent_CallContext_Callee = 2
};
bool FunctionEvent_CallContext_IsValid(int value);
const FunctionEvent_CallContext FunctionEvent_CallContext_CallContext_MIN = FunctionEvent_CallContext_Caller;
const FunctionEvent_CallContext FunctionEvent_CallContext_CallContext_MAX = FunctionEvent_CallContext_Callee;
const int FunctionEvent_CallContext_CallContext_ARRAYSIZE = FunctionEvent_CallContext_CallContext_MAX + 1;

const ::google::protobuf::EnumDescriptor* FunctionEvent_CallContext_descriptor();
inline const ::std::string& FunctionEvent_CallContext_Name(FunctionEvent_CallContext value) {
  return ::google::protobuf::internal::NameOfEnum(
    FunctionEvent_CallContext_descriptor(), value);
}
inline bool FunctionEvent_CallContext_Parse(
    const ::std::string& name, FunctionEvent_CallContext* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FunctionEvent_CallContext>(
    FunctionEvent_CallContext_descriptor(), name, value);
}
enum FunctionEvent_CallKind {
  FunctionEvent_CallKind_CCall = 1,
  FunctionEvent_CallKind_ObjCInstanceMessage = 2,
  FunctionEvent_CallKind_ObjCClassMessage = 3,
  FunctionEvent_CallKind_ObjCSuperMessage = 4
};
bool FunctionEvent_CallKind_IsValid(int value);
const FunctionEvent_CallKind FunctionEvent_CallKind_CallKind_MIN = FunctionEvent_CallKind_CCall;
const FunctionEvent_CallKind FunctionEvent_CallKind_CallKind_MAX = FunctionEvent_CallKind_ObjCSuperMessage;
const int FunctionEvent_CallKind_CallKind_ARRAYSIZE = FunctionEvent_CallKind_CallKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* FunctionEvent_CallKind_descriptor();
inline const ::std::string& FunctionEvent_CallKind_Name(FunctionEvent_CallKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    FunctionEvent_CallKind_descriptor(), value);
}
inline bool FunctionEvent_CallKind_Parse(
    const ::std::string& name, FunctionEvent_CallKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FunctionEvent_CallKind>(
    FunctionEvent_CallKind_descriptor(), name, value);
}
enum FieldAssignment_AssignType {
  FieldAssignment_AssignType_SimpleAssign = 1,
  FieldAssignment_AssignType_PlusEqual = 2,
  FieldAssignment_AssignType_MinusEqual = 3
};
bool FieldAssignment_AssignType_IsValid(int value);
const FieldAssignment_AssignType FieldAssignment_AssignType_AssignType_MIN = FieldAssignment_AssignType_SimpleAssign;
const FieldAssignment_AssignType FieldAssignment_AssignType_AssignType_MAX = FieldAssignment_AssignType_MinusEqual;
const int FieldAssignment_AssignType_AssignType_ARRAYSIZE = FieldAssignment_AssignType_AssignType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FieldAssignment_AssignType_descriptor();
inline const ::std::string& FieldAssignment_AssignType_Name(FieldAssignment_AssignType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FieldAssignment_AssignType_descriptor(), value);
}
inline bool FieldAssignment_AssignType_Parse(
    const ::std::string& name, FieldAssignment_AssignType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FieldAssignment_AssignType>(
    FieldAssignment_AssignType_descriptor(), name, value);
}
enum Argument_Type {
  Argument_Type_Constant = 1,
  Argument_Type_Variable = 2,
  Argument_Type_Any = 3,
  Argument_Type_Indirect = 4,
  Argument_Type_Field = 5
};
bool Argument_Type_IsValid(int value);
const Argument_Type Argument_Type_Type_MIN = Argument_Type_Constant;
const Argument_Type Argument_Type_Type_MAX = Argument_Type_Field;
const int Argument_Type_Type_ARRAYSIZE = Argument_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Argument_Type_descriptor();
inline const ::std::string& Argument_Type_Name(Argument_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Argument_Type_descriptor(), value);
}
inline bool Argument_Type_Parse(
    const ::std::string& name, Argument_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Argument_Type>(
    Argument_Type_descriptor(), name, value);
}
enum Argument_MatchType {
  Argument_MatchType_Exact = 1,
  Argument_MatchType_Flags = 2,
  Argument_MatchType_Mask = 3
};
bool Argument_MatchType_IsValid(int value);
const Argument_MatchType Argument_MatchType_MatchType_MIN = Argument_MatchType_Exact;
const Argument_MatchType Argument_MatchType_MatchType_MAX = Argument_MatchType_Mask;
const int Argument_MatchType_MatchType_ARRAYSIZE = Argument_MatchType_MatchType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Argument_MatchType_descriptor();
inline const ::std::string& Argument_MatchType_Name(Argument_MatchType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Argument_MatchType_descriptor(), value);
}
inline bool Argument_MatchType_Parse(
    const ::std::string& name, Argument_MatchType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Argument_MatchType>(
    Argument_MatchType_descriptor(), name, value);
}
// ===================================================================

class ManifestFile : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tesla.ManifestFile) */ {
 public:
  ManifestFile();
  virtual ~ManifestFile();

  ManifestFile(const ManifestFile& from);

  inline ManifestFile& operator=(const ManifestFile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ManifestFile& default_instance();

  void Swap(ManifestFile* other);

  // implements Message ----------------------------------------------

  inline ManifestFile* New() const { return New(NULL); }

  ManifestFile* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ManifestFile& from);
  void MergeFrom(const ManifestFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ManifestFile* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tesla.AutomatonDescription automaton = 1;
  int automaton_size() const;
  void clear_automaton();
  static const int kAutomatonFieldNumber = 1;
  const ::tesla::AutomatonDescription& automaton(int index) const;
  ::tesla::AutomatonDescription* mutable_automaton(int index);
  ::tesla::AutomatonDescription* add_automaton();
  ::google::protobuf::RepeatedPtrField< ::tesla::AutomatonDescription >*
      mutable_automaton();
  const ::google::protobuf::RepeatedPtrField< ::tesla::AutomatonDescription >&
      automaton() const;

  // repeated .tesla.Usage root = 2;
  int root_size() const;
  void clear_root();
  static const int kRootFieldNumber = 2;
  const ::tesla::Usage& root(int index) const;
  ::tesla::Usage* mutable_root(int index);
  ::tesla::Usage* add_root();
  ::google::protobuf::RepeatedPtrField< ::tesla::Usage >*
      mutable_root();
  const ::google::protobuf::RepeatedPtrField< ::tesla::Usage >&
      root() const;

  // @@protoc_insertion_point(class_scope:tesla.ManifestFile)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::tesla::AutomatonDescription > automaton_;
  ::google::protobuf::RepeatedPtrField< ::tesla::Usage > root_;
  friend void  protobuf_AddDesc_tesla_2eproto();
  friend void protobuf_AssignDesc_tesla_2eproto();
  friend void protobuf_ShutdownFile_tesla_2eproto();

  void InitAsDefaultInstance();
  static ManifestFile* default_instance_;
};
// -------------------------------------------------------------------

class Usage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tesla.Usage) */ {
 public:
  Usage();
  virtual ~Usage();

  Usage(const Usage& from);

  inline Usage& operator=(const Usage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Usage& default_instance();

  void Swap(Usage* other);

  // implements Message ----------------------------------------------

  inline Usage* New() const { return New(NULL); }

  Usage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Usage& from);
  void MergeFrom(const Usage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Usage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .tesla.Identifier identifier = 1;
  bool has_identifier() const;
  void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  const ::tesla::Identifier& identifier() const;
  ::tesla::Identifier* mutable_identifier();
  ::tesla::Identifier* release_identifier();
  void set_allocated_identifier(::tesla::Identifier* identifier);

  // required uint64 uniqueId = 2;
  bool has_uniqueid() const;
  void clear_uniqueid();
  static const int kUniqueIdFieldNumber = 2;
  ::google::protobuf::uint64 uniqueid() const;
  void set_uniqueid(::google::protobuf::uint64 value);

  // optional .tesla.Expression beginning = 3;
  bool has_beginning() const;
  void clear_beginning();
  static const int kBeginningFieldNumber = 3;
  const ::tesla::Expression& beginning() const;
  ::tesla::Expression* mutable_beginning();
  ::tesla::Expression* release_beginning();
  void set_allocated_beginning(::tesla::Expression* beginning);

  // optional .tesla.Expression end = 4;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 4;
  const ::tesla::Expression& end() const;
  ::tesla::Expression* mutable_end();
  ::tesla::Expression* release_end();
  void set_allocated_end(::tesla::Expression* end);

  // optional bool deleted = 5 [default = false];
  bool has_deleted() const;
  void clear_deleted();
  static const int kDeletedFieldNumber = 5;
  bool deleted() const;
  void set_deleted(bool value);

  // @@protoc_insertion_point(class_scope:tesla.Usage)
 private:
  inline void set_has_identifier();
  inline void clear_has_identifier();
  inline void set_has_uniqueid();
  inline void clear_has_uniqueid();
  inline void set_has_beginning();
  inline void clear_has_beginning();
  inline void set_has_end();
  inline void clear_has_end();
  inline void set_has_deleted();
  inline void clear_has_deleted();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::tesla::Identifier* identifier_;
  ::google::protobuf::uint64 uniqueid_;
  ::tesla::Expression* beginning_;
  ::tesla::Expression* end_;
  bool deleted_;
  friend void  protobuf_AddDesc_tesla_2eproto();
  friend void protobuf_AssignDesc_tesla_2eproto();
  friend void protobuf_ShutdownFile_tesla_2eproto();

  void InitAsDefaultInstance();
  static Usage* default_instance_;
};
// -------------------------------------------------------------------

class AutomatonDescription : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tesla.AutomatonDescription) */ {
 public:
  AutomatonDescription();
  virtual ~AutomatonDescription();

  AutomatonDescription(const AutomatonDescription& from);

  inline AutomatonDescription& operator=(const AutomatonDescription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AutomatonDescription& default_instance();

  void Swap(AutomatonDescription* other);

  // implements Message ----------------------------------------------

  inline AutomatonDescription* New() const { return New(NULL); }

  AutomatonDescription* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AutomatonDescription& from);
  void MergeFrom(const AutomatonDescription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutomatonDescription* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AutomatonDescription_Context Context;
  static const Context Global =
    AutomatonDescription_Context_Global;
  static const Context ThreadLocal =
    AutomatonDescription_Context_ThreadLocal;
  static inline bool Context_IsValid(int value) {
    return AutomatonDescription_Context_IsValid(value);
  }
  static const Context Context_MIN =
    AutomatonDescription_Context_Context_MIN;
  static const Context Context_MAX =
    AutomatonDescription_Context_Context_MAX;
  static const int Context_ARRAYSIZE =
    AutomatonDescription_Context_Context_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Context_descriptor() {
    return AutomatonDescription_Context_descriptor();
  }
  static inline const ::std::string& Context_Name(Context value) {
    return AutomatonDescription_Context_Name(value);
  }
  static inline bool Context_Parse(const ::std::string& name,
      Context* value) {
    return AutomatonDescription_Context_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .tesla.Identifier identifier = 1;
  bool has_identifier() const;
  void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  const ::tesla::Identifier& identifier() const;
  ::tesla::Identifier* mutable_identifier();
  ::tesla::Identifier* release_identifier();
  void set_allocated_identifier(::tesla::Identifier* identifier);

  // required .tesla.AutomatonDescription.Context context = 2;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 2;
  ::tesla::AutomatonDescription_Context context() const;
  void set_context(::tesla::AutomatonDescription_Context value);

  // required .tesla.Expression expression = 3;
  bool has_expression() const;
  void clear_expression();
  static const int kExpressionFieldNumber = 3;
  const ::tesla::Expression& expression() const;
  ::tesla::Expression* mutable_expression();
  ::tesla::Expression* release_expression();
  void set_allocated_expression(::tesla::Expression* expression);

  // repeated .tesla.Argument argument = 5;
  int argument_size() const;
  void clear_argument();
  static const int kArgumentFieldNumber = 5;
  const ::tesla::Argument& argument(int index) const;
  ::tesla::Argument* mutable_argument(int index);
  ::tesla::Argument* add_argument();
  ::google::protobuf::RepeatedPtrField< ::tesla::Argument >*
      mutable_argument();
  const ::google::protobuf::RepeatedPtrField< ::tesla::Argument >&
      argument() const;

  // optional string source = 6;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 6;
  const ::std::string& source() const;
  void set_source(const ::std::string& value);
  void set_source(const char* value);
  void set_source(const char* value, size_t size);
  ::std::string* mutable_source();
  ::std::string* release_source();
  void set_allocated_source(::std::string* source);

  // @@protoc_insertion_point(class_scope:tesla.AutomatonDescription)
 private:
  inline void set_has_identifier();
  inline void clear_has_identifier();
  inline void set_has_context();
  inline void clear_has_context();
  inline void set_has_expression();
  inline void clear_has_expression();
  inline void set_has_source();
  inline void clear_has_source();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::tesla::Identifier* identifier_;
  ::tesla::Expression* expression_;
  ::google::protobuf::RepeatedPtrField< ::tesla::Argument > argument_;
  ::google::protobuf::internal::ArenaStringPtr source_;
  int context_;
  friend void  protobuf_AddDesc_tesla_2eproto();
  friend void protobuf_AssignDesc_tesla_2eproto();
  friend void protobuf_ShutdownFile_tesla_2eproto();

  void InitAsDefaultInstance();
  static AutomatonDescription* default_instance_;
};
// -------------------------------------------------------------------

class Identifier : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tesla.Identifier) */ {
 public:
  Identifier();
  virtual ~Identifier();

  Identifier(const Identifier& from);

  inline Identifier& operator=(const Identifier& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Identifier& default_instance();

  void Swap(Identifier* other);

  // implements Message ----------------------------------------------

  inline Identifier* New() const { return New(NULL); }

  Identifier* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Identifier& from);
  void MergeFrom(const Identifier& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Identifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .tesla.Location location = 2;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 2;
  const ::tesla::Location& location() const;
  ::tesla::Location* mutable_location();
  ::tesla::Location* release_location();
  void set_allocated_location(::tesla::Location* location);

  // @@protoc_insertion_point(class_scope:tesla.Identifier)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_location();
  inline void clear_has_location();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::tesla::Location* location_;
  friend void  protobuf_AddDesc_tesla_2eproto();
  friend void protobuf_AssignDesc_tesla_2eproto();
  friend void protobuf_ShutdownFile_tesla_2eproto();

  void InitAsDefaultInstance();
  static Identifier* default_instance_;
};
// -------------------------------------------------------------------

class Location : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tesla.Location) */ {
 public:
  Location();
  virtual ~Location();

  Location(const Location& from);

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Location& default_instance();

  void Swap(Location* other);

  // implements Message ----------------------------------------------

  inline Location* New() const { return New(NULL); }

  Location* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Location& from);
  void MergeFrom(const Location& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Location* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string filename = 1;
  bool has_filename() const;
  void clear_filename();
  static const int kFilenameFieldNumber = 1;
  const ::std::string& filename() const;
  void set_filename(const ::std::string& value);
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  ::std::string* mutable_filename();
  ::std::string* release_filename();
  void set_allocated_filename(::std::string* filename);

  // required int32 line = 2;
  bool has_line() const;
  void clear_line();
  static const int kLineFieldNumber = 2;
  ::google::protobuf::int32 line() const;
  void set_line(::google::protobuf::int32 value);

  // required int32 counter = 3;
  bool has_counter() const;
  void clear_counter();
  static const int kCounterFieldNumber = 3;
  ::google::protobuf::int32 counter() const;
  void set_counter(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tesla.Location)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_line();
  inline void clear_has_line();
  inline void set_has_counter();
  inline void clear_has_counter();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr filename_;
  ::google::protobuf::int32 line_;
  ::google::protobuf::int32 counter_;
  friend void  protobuf_AddDesc_tesla_2eproto();
  friend void protobuf_AssignDesc_tesla_2eproto();
  friend void protobuf_ShutdownFile_tesla_2eproto();

  void InitAsDefaultInstance();
  static Location* default_instance_;
};
// -------------------------------------------------------------------

class Expression : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tesla.Expression) */ {
 public:
  Expression();
  virtual ~Expression();

  Expression(const Expression& from);

  inline Expression& operator=(const Expression& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression& default_instance();

  void Swap(Expression* other);

  // implements Message ----------------------------------------------

  inline Expression* New() const { return New(NULL); }

  Expression* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Expression& from);
  void MergeFrom(const Expression& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Expression* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Expression_Type Type;
  static const Type BOOLEAN_EXPR =
    Expression_Type_BOOLEAN_EXPR;
  static const Type SEQUENCE =
    Expression_Type_SEQUENCE;
  static const Type NULL_EXPR =
    Expression_Type_NULL_EXPR;
  static const Type ASSERTION_SITE =
    Expression_Type_ASSERTION_SITE;
  static const Type FUNCTION =
    Expression_Type_FUNCTION;
  static const Type FIELD_ASSIGN =
    Expression_Type_FIELD_ASSIGN;
  static const Type SUB_AUTOMATON =
    Expression_Type_SUB_AUTOMATON;
  static inline bool Type_IsValid(int value) {
    return Expression_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Expression_Type_Type_MIN;
  static const Type Type_MAX =
    Expression_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Expression_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Expression_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Expression_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Expression_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .tesla.Expression.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::tesla::Expression_Type type() const;
  void set_type(::tesla::Expression_Type value);

  // optional .tesla.BooleanExpr booleanExpr = 2;
  bool has_booleanexpr() const;
  void clear_booleanexpr();
  static const int kBooleanExprFieldNumber = 2;
  const ::tesla::BooleanExpr& booleanexpr() const;
  ::tesla::BooleanExpr* mutable_booleanexpr();
  ::tesla::BooleanExpr* release_booleanexpr();
  void set_allocated_booleanexpr(::tesla::BooleanExpr* booleanexpr);

  // optional .tesla.Sequence sequence = 3;
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 3;
  const ::tesla::Sequence& sequence() const;
  ::tesla::Sequence* mutable_sequence();
  ::tesla::Sequence* release_sequence();
  void set_allocated_sequence(::tesla::Sequence* sequence);

  // optional .tesla.AssertionSite assertSite = 4;
  bool has_assertsite() const;
  void clear_assertsite();
  static const int kAssertSiteFieldNumber = 4;
  const ::tesla::AssertionSite& assertsite() const;
  ::tesla::AssertionSite* mutable_assertsite();
  ::tesla::AssertionSite* release_assertsite();
  void set_allocated_assertsite(::tesla::AssertionSite* assertsite);

  // optional .tesla.FunctionEvent function = 5;
  bool has_function() const;
  void clear_function();
  static const int kFunctionFieldNumber = 5;
  const ::tesla::FunctionEvent& function() const;
  ::tesla::FunctionEvent* mutable_function();
  ::tesla::FunctionEvent* release_function();
  void set_allocated_function(::tesla::FunctionEvent* function);

  // optional .tesla.FieldAssignment fieldAssign = 6;
  bool has_fieldassign() const;
  void clear_fieldassign();
  static const int kFieldAssignFieldNumber = 6;
  const ::tesla::FieldAssignment& fieldassign() const;
  ::tesla::FieldAssignment* mutable_fieldassign();
  ::tesla::FieldAssignment* release_fieldassign();
  void set_allocated_fieldassign(::tesla::FieldAssignment* fieldassign);

  // optional .tesla.Identifier subAutomaton = 7;
  bool has_subautomaton() const;
  void clear_subautomaton();
  static const int kSubAutomatonFieldNumber = 7;
  const ::tesla::Identifier& subautomaton() const;
  ::tesla::Identifier* mutable_subautomaton();
  ::tesla::Identifier* release_subautomaton();
  void set_allocated_subautomaton(::tesla::Identifier* subautomaton);

  // @@protoc_insertion_point(class_scope:tesla.Expression)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_booleanexpr();
  inline void clear_has_booleanexpr();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_assertsite();
  inline void clear_has_assertsite();
  inline void set_has_function();
  inline void clear_has_function();
  inline void set_has_fieldassign();
  inline void clear_has_fieldassign();
  inline void set_has_subautomaton();
  inline void clear_has_subautomaton();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::tesla::BooleanExpr* booleanexpr_;
  ::tesla::Sequence* sequence_;
  ::tesla::AssertionSite* assertsite_;
  ::tesla::FunctionEvent* function_;
  ::tesla::FieldAssignment* fieldassign_;
  ::tesla::Identifier* subautomaton_;
  int type_;
  friend void  protobuf_AddDesc_tesla_2eproto();
  friend void protobuf_AssignDesc_tesla_2eproto();
  friend void protobuf_ShutdownFile_tesla_2eproto();

  void InitAsDefaultInstance();
  static Expression* default_instance_;
};
// -------------------------------------------------------------------

class BooleanExpr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tesla.BooleanExpr) */ {
 public:
  BooleanExpr();
  virtual ~BooleanExpr();

  BooleanExpr(const BooleanExpr& from);

  inline BooleanExpr& operator=(const BooleanExpr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BooleanExpr& default_instance();

  void Swap(BooleanExpr* other);

  // implements Message ----------------------------------------------

  inline BooleanExpr* New() const { return New(NULL); }

  BooleanExpr* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BooleanExpr& from);
  void MergeFrom(const BooleanExpr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BooleanExpr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef BooleanExpr_Operation Operation;
  static const Operation BE_And =
    BooleanExpr_Operation_BE_And;
  static const Operation BE_Or =
    BooleanExpr_Operation_BE_Or;
  static const Operation BE_Xor =
    BooleanExpr_Operation_BE_Xor;
  static inline bool Operation_IsValid(int value) {
    return BooleanExpr_Operation_IsValid(value);
  }
  static const Operation Operation_MIN =
    BooleanExpr_Operation_Operation_MIN;
  static const Operation Operation_MAX =
    BooleanExpr_Operation_Operation_MAX;
  static const int Operation_ARRAYSIZE =
    BooleanExpr_Operation_Operation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Operation_descriptor() {
    return BooleanExpr_Operation_descriptor();
  }
  static inline const ::std::string& Operation_Name(Operation value) {
    return BooleanExpr_Operation_Name(value);
  }
  static inline bool Operation_Parse(const ::std::string& name,
      Operation* value) {
    return BooleanExpr_Operation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .tesla.BooleanExpr.Operation operation = 1;
  bool has_operation() const;
  void clear_operation();
  static const int kOperationFieldNumber = 1;
  ::tesla::BooleanExpr_Operation operation() const;
  void set_operation(::tesla::BooleanExpr_Operation value);

  // repeated .tesla.Expression expression = 2;
  int expression_size() const;
  void clear_expression();
  static const int kExpressionFieldNumber = 2;
  const ::tesla::Expression& expression(int index) const;
  ::tesla::Expression* mutable_expression(int index);
  ::tesla::Expression* add_expression();
  ::google::protobuf::RepeatedPtrField< ::tesla::Expression >*
      mutable_expression();
  const ::google::protobuf::RepeatedPtrField< ::tesla::Expression >&
      expression() const;

  // @@protoc_insertion_point(class_scope:tesla.BooleanExpr)
 private:
  inline void set_has_operation();
  inline void clear_has_operation();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::tesla::Expression > expression_;
  int operation_;
  friend void  protobuf_AddDesc_tesla_2eproto();
  friend void protobuf_AssignDesc_tesla_2eproto();
  friend void protobuf_ShutdownFile_tesla_2eproto();

  void InitAsDefaultInstance();
  static BooleanExpr* default_instance_;
};
// -------------------------------------------------------------------

class Sequence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tesla.Sequence) */ {
 public:
  Sequence();
  virtual ~Sequence();

  Sequence(const Sequence& from);

  inline Sequence& operator=(const Sequence& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sequence& default_instance();

  void Swap(Sequence* other);

  // implements Message ----------------------------------------------

  inline Sequence* New() const { return New(NULL); }

  Sequence* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sequence& from);
  void MergeFrom(const Sequence& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Sequence* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tesla.Expression expression = 1;
  int expression_size() const;
  void clear_expression();
  static const int kExpressionFieldNumber = 1;
  const ::tesla::Expression& expression(int index) const;
  ::tesla::Expression* mutable_expression(int index);
  ::tesla::Expression* add_expression();
  ::google::protobuf::RepeatedPtrField< ::tesla::Expression >*
      mutable_expression();
  const ::google::protobuf::RepeatedPtrField< ::tesla::Expression >&
      expression() const;

  // optional int32 minReps = 2 [default = 1];
  bool has_minreps() const;
  void clear_minreps();
  static const int kMinRepsFieldNumber = 2;
  ::google::protobuf::int32 minreps() const;
  void set_minreps(::google::protobuf::int32 value);

  // optional int32 maxReps = 3 [default = 1];
  bool has_maxreps() const;
  void clear_maxreps();
  static const int kMaxRepsFieldNumber = 3;
  ::google::protobuf::int32 maxreps() const;
  void set_maxreps(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tesla.Sequence)
 private:
  inline void set_has_minreps();
  inline void clear_has_minreps();
  inline void set_has_maxreps();
  inline void clear_has_maxreps();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::tesla::Expression > expression_;
  ::google::protobuf::int32 minreps_;
  ::google::protobuf::int32 maxreps_;
  friend void  protobuf_AddDesc_tesla_2eproto();
  friend void protobuf_AssignDesc_tesla_2eproto();
  friend void protobuf_ShutdownFile_tesla_2eproto();

  void InitAsDefaultInstance();
  static Sequence* default_instance_;
};
// -------------------------------------------------------------------

class AssertionSite : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tesla.AssertionSite) */ {
 public:
  AssertionSite();
  virtual ~AssertionSite();

  AssertionSite(const AssertionSite& from);

  inline AssertionSite& operator=(const AssertionSite& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AssertionSite& default_instance();

  void Swap(AssertionSite* other);

  // implements Message ----------------------------------------------

  inline AssertionSite* New() const { return New(NULL); }

  AssertionSite* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AssertionSite& from);
  void MergeFrom(const AssertionSite& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AssertionSite* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .tesla.Location location = 1;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::tesla::Location& location() const;
  ::tesla::Location* mutable_location();
  ::tesla::Location* release_location();
  void set_allocated_location(::tesla::Location* location);

  // optional .tesla.FunctionRef function = 2;
  bool has_function() const;
  void clear_function();
  static const int kFunctionFieldNumber = 2;
  const ::tesla::FunctionRef& function() const;
  ::tesla::FunctionRef* mutable_function();
  ::tesla::FunctionRef* release_function();
  void set_allocated_function(::tesla::FunctionRef* function);

  // @@protoc_insertion_point(class_scope:tesla.AssertionSite)
 private:
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_function();
  inline void clear_has_function();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::tesla::Location* location_;
  ::tesla::FunctionRef* function_;
  friend void  protobuf_AddDesc_tesla_2eproto();
  friend void protobuf_AssignDesc_tesla_2eproto();
  friend void protobuf_ShutdownFile_tesla_2eproto();

  void InitAsDefaultInstance();
  static AssertionSite* default_instance_;
};
// -------------------------------------------------------------------

class FunctionEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tesla.FunctionEvent) */ {
 public:
  FunctionEvent();
  virtual ~FunctionEvent();

  FunctionEvent(const FunctionEvent& from);

  inline FunctionEvent& operator=(const FunctionEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FunctionEvent& default_instance();

  void Swap(FunctionEvent* other);

  // implements Message ----------------------------------------------

  inline FunctionEvent* New() const { return New(NULL); }

  FunctionEvent* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FunctionEvent& from);
  void MergeFrom(const FunctionEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FunctionEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef FunctionEvent_Direction Direction;
  static const Direction Entry =
    FunctionEvent_Direction_Entry;
  static const Direction Exit =
    FunctionEvent_Direction_Exit;
  static inline bool Direction_IsValid(int value) {
    return FunctionEvent_Direction_IsValid(value);
  }
  static const Direction Direction_MIN =
    FunctionEvent_Direction_Direction_MIN;
  static const Direction Direction_MAX =
    FunctionEvent_Direction_Direction_MAX;
  static const int Direction_ARRAYSIZE =
    FunctionEvent_Direction_Direction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Direction_descriptor() {
    return FunctionEvent_Direction_descriptor();
  }
  static inline const ::std::string& Direction_Name(Direction value) {
    return FunctionEvent_Direction_Name(value);
  }
  static inline bool Direction_Parse(const ::std::string& name,
      Direction* value) {
    return FunctionEvent_Direction_Parse(name, value);
  }

  typedef FunctionEvent_CallContext CallContext;
  static const CallContext Caller =
    FunctionEvent_CallContext_Caller;
  static const CallContext Callee =
    FunctionEvent_CallContext_Callee;
  static inline bool CallContext_IsValid(int value) {
    return FunctionEvent_CallContext_IsValid(value);
  }
  static const CallContext CallContext_MIN =
    FunctionEvent_CallContext_CallContext_MIN;
  static const CallContext CallContext_MAX =
    FunctionEvent_CallContext_CallContext_MAX;
  static const int CallContext_ARRAYSIZE =
    FunctionEvent_CallContext_CallContext_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CallContext_descriptor() {
    return FunctionEvent_CallContext_descriptor();
  }
  static inline const ::std::string& CallContext_Name(CallContext value) {
    return FunctionEvent_CallContext_Name(value);
  }
  static inline bool CallContext_Parse(const ::std::string& name,
      CallContext* value) {
    return FunctionEvent_CallContext_Parse(name, value);
  }

  typedef FunctionEvent_CallKind CallKind;
  static const CallKind CCall =
    FunctionEvent_CallKind_CCall;
  static const CallKind ObjCInstanceMessage =
    FunctionEvent_CallKind_ObjCInstanceMessage;
  static const CallKind ObjCClassMessage =
    FunctionEvent_CallKind_ObjCClassMessage;
  static const CallKind ObjCSuperMessage =
    FunctionEvent_CallKind_ObjCSuperMessage;
  static inline bool CallKind_IsValid(int value) {
    return FunctionEvent_CallKind_IsValid(value);
  }
  static const CallKind CallKind_MIN =
    FunctionEvent_CallKind_CallKind_MIN;
  static const CallKind CallKind_MAX =
    FunctionEvent_CallKind_CallKind_MAX;
  static const int CallKind_ARRAYSIZE =
    FunctionEvent_CallKind_CallKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CallKind_descriptor() {
    return FunctionEvent_CallKind_descriptor();
  }
  static inline const ::std::string& CallKind_Name(CallKind value) {
    return FunctionEvent_CallKind_Name(value);
  }
  static inline bool CallKind_Parse(const ::std::string& name,
      CallKind* value) {
    return FunctionEvent_CallKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .tesla.FunctionRef function = 1;
  bool has_function() const;
  void clear_function();
  static const int kFunctionFieldNumber = 1;
  const ::tesla::FunctionRef& function() const;
  ::tesla::FunctionRef* mutable_function();
  ::tesla::FunctionRef* release_function();
  void set_allocated_function(::tesla::FunctionRef* function);

  // optional .tesla.FunctionEvent.Direction direction = 2;
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 2;
  ::tesla::FunctionEvent_Direction direction() const;
  void set_direction(::tesla::FunctionEvent_Direction value);

  // optional .tesla.FunctionEvent.CallContext context = 3;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 3;
  ::tesla::FunctionEvent_CallContext context() const;
  void set_context(::tesla::FunctionEvent_CallContext value);

  // repeated .tesla.Argument argument = 4;
  int argument_size() const;
  void clear_argument();
  static const int kArgumentFieldNumber = 4;
  const ::tesla::Argument& argument(int index) const;
  ::tesla::Argument* mutable_argument(int index);
  ::tesla::Argument* add_argument();
  ::google::protobuf::RepeatedPtrField< ::tesla::Argument >*
      mutable_argument();
  const ::google::protobuf::RepeatedPtrField< ::tesla::Argument >&
      argument() const;

  // optional .tesla.Argument expectedReturnValue = 5;
  bool has_expectedreturnvalue() const;
  void clear_expectedreturnvalue();
  static const int kExpectedReturnValueFieldNumber = 5;
  const ::tesla::Argument& expectedreturnvalue() const;
  ::tesla::Argument* mutable_expectedreturnvalue();
  ::tesla::Argument* release_expectedreturnvalue();
  void set_allocated_expectedreturnvalue(::tesla::Argument* expectedreturnvalue);

  // optional bool strict = 6 [default = true];
  bool has_strict() const;
  void clear_strict();
  static const int kStrictFieldNumber = 6;
  bool strict() const;
  void set_strict(bool value);

  // optional .tesla.FunctionEvent.CallKind kind = 7 [default = CCall];
  bool has_kind() const;
  void clear_kind();
  static const int kKindFieldNumber = 7;
  ::tesla::FunctionEvent_CallKind kind() const;
  void set_kind(::tesla::FunctionEvent_CallKind value);

  // optional .tesla.Argument receiver = 8;
  bool has_receiver() const;
  void clear_receiver();
  static const int kReceiverFieldNumber = 8;
  const ::tesla::Argument& receiver() const;
  ::tesla::Argument* mutable_receiver();
  ::tesla::Argument* release_receiver();
  void set_allocated_receiver(::tesla::Argument* receiver);

  // @@protoc_insertion_point(class_scope:tesla.FunctionEvent)
 private:
  inline void set_has_function();
  inline void clear_has_function();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_context();
  inline void clear_has_context();
  inline void set_has_expectedreturnvalue();
  inline void clear_has_expectedreturnvalue();
  inline void set_has_strict();
  inline void clear_has_strict();
  inline void set_has_kind();
  inline void clear_has_kind();
  inline void set_has_receiver();
  inline void clear_has_receiver();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::tesla::FunctionRef* function_;
  int direction_;
  int context_;
  ::google::protobuf::RepeatedPtrField< ::tesla::Argument > argument_;
  ::tesla::Argument* expectedreturnvalue_;
  bool strict_;
  int kind_;
  ::tesla::Argument* receiver_;
  friend void  protobuf_AddDesc_tesla_2eproto();
  friend void protobuf_AssignDesc_tesla_2eproto();
  friend void protobuf_ShutdownFile_tesla_2eproto();

  void InitAsDefaultInstance();
  static FunctionEvent* default_instance_;
};
// -------------------------------------------------------------------

class FunctionRef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tesla.FunctionRef) */ {
 public:
  FunctionRef();
  virtual ~FunctionRef();

  FunctionRef(const FunctionRef& from);

  inline FunctionRef& operator=(const FunctionRef& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FunctionRef& default_instance();

  void Swap(FunctionRef* other);

  // implements Message ----------------------------------------------

  inline FunctionRef* New() const { return New(NULL); }

  FunctionRef* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FunctionRef& from);
  void MergeFrom(const FunctionRef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FunctionRef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:tesla.FunctionRef)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend void  protobuf_AddDesc_tesla_2eproto();
  friend void protobuf_AssignDesc_tesla_2eproto();
  friend void protobuf_ShutdownFile_tesla_2eproto();

  void InitAsDefaultInstance();
  static FunctionRef* default_instance_;
};
// -------------------------------------------------------------------

class FieldAssignment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tesla.FieldAssignment) */ {
 public:
  FieldAssignment();
  virtual ~FieldAssignment();

  FieldAssignment(const FieldAssignment& from);

  inline FieldAssignment& operator=(const FieldAssignment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FieldAssignment& default_instance();

  void Swap(FieldAssignment* other);

  // implements Message ----------------------------------------------

  inline FieldAssignment* New() const { return New(NULL); }

  FieldAssignment* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FieldAssignment& from);
  void MergeFrom(const FieldAssignment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FieldAssignment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef FieldAssignment_AssignType AssignType;
  static const AssignType SimpleAssign =
    FieldAssignment_AssignType_SimpleAssign;
  static const AssignType PlusEqual =
    FieldAssignment_AssignType_PlusEqual;
  static const AssignType MinusEqual =
    FieldAssignment_AssignType_MinusEqual;
  static inline bool AssignType_IsValid(int value) {
    return FieldAssignment_AssignType_IsValid(value);
  }
  static const AssignType AssignType_MIN =
    FieldAssignment_AssignType_AssignType_MIN;
  static const AssignType AssignType_MAX =
    FieldAssignment_AssignType_AssignType_MAX;
  static const int AssignType_ARRAYSIZE =
    FieldAssignment_AssignType_AssignType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AssignType_descriptor() {
    return FieldAssignment_AssignType_descriptor();
  }
  static inline const ::std::string& AssignType_Name(AssignType value) {
    return FieldAssignment_AssignType_Name(value);
  }
  static inline bool AssignType_Parse(const ::std::string& name,
      AssignType* value) {
    return FieldAssignment_AssignType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .tesla.StructField field = 8;
  bool has_field() const;
  void clear_field();
  static const int kFieldFieldNumber = 8;
  const ::tesla::StructField& field() const;
  ::tesla::StructField* mutable_field();
  ::tesla::StructField* release_field();
  void set_allocated_field(::tesla::StructField* field);

  // required .tesla.FieldAssignment.AssignType operation = 4;
  bool has_operation() const;
  void clear_operation();
  static const int kOperationFieldNumber = 4;
  ::tesla::FieldAssignment_AssignType operation() const;
  void set_operation(::tesla::FieldAssignment_AssignType value);

  // required .tesla.Argument value = 5;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 5;
  const ::tesla::Argument& value() const;
  ::tesla::Argument* mutable_value();
  ::tesla::Argument* release_value();
  void set_allocated_value(::tesla::Argument* value);

  // optional bool strict = 7 [default = true];
  bool has_strict() const;
  void clear_strict();
  static const int kStrictFieldNumber = 7;
  bool strict() const;
  void set_strict(bool value);

  // @@protoc_insertion_point(class_scope:tesla.FieldAssignment)
 private:
  inline void set_has_field();
  inline void clear_has_field();
  inline void set_has_operation();
  inline void clear_has_operation();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_strict();
  inline void clear_has_strict();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::tesla::StructField* field_;
  ::tesla::Argument* value_;
  int operation_;
  bool strict_;
  friend void  protobuf_AddDesc_tesla_2eproto();
  friend void protobuf_AssignDesc_tesla_2eproto();
  friend void protobuf_ShutdownFile_tesla_2eproto();

  void InitAsDefaultInstance();
  static FieldAssignment* default_instance_;
};
// -------------------------------------------------------------------

class StructField : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tesla.StructField) */ {
 public:
  StructField();
  virtual ~StructField();

  StructField(const StructField& from);

  inline StructField& operator=(const StructField& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StructField& default_instance();

  void Swap(StructField* other);

  // implements Message ----------------------------------------------

  inline StructField* New() const { return New(NULL); }

  StructField* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StructField& from);
  void MergeFrom(const StructField& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StructField* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // required .tesla.Argument base = 2;
  bool has_base() const;
  void clear_base();
  static const int kBaseFieldNumber = 2;
  const ::tesla::Argument& base() const;
  ::tesla::Argument* mutable_base();
  ::tesla::Argument* release_base();
  void set_allocated_base(::tesla::Argument* base);

  // required string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required int32 index = 4;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 4;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tesla.StructField)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_index();
  inline void clear_has_index();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::tesla::Argument* base_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 index_;
  friend void  protobuf_AddDesc_tesla_2eproto();
  friend void protobuf_AssignDesc_tesla_2eproto();
  friend void protobuf_ShutdownFile_tesla_2eproto();

  void InitAsDefaultInstance();
  static StructField* default_instance_;
};
// -------------------------------------------------------------------

class Argument : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tesla.Argument) */ {
 public:
  Argument();
  virtual ~Argument();

  Argument(const Argument& from);

  inline Argument& operator=(const Argument& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Argument& default_instance();

  void Swap(Argument* other);

  // implements Message ----------------------------------------------

  inline Argument* New() const { return New(NULL); }

  Argument* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Argument& from);
  void MergeFrom(const Argument& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Argument* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Argument_Type Type;
  static const Type Constant =
    Argument_Type_Constant;
  static const Type Variable =
    Argument_Type_Variable;
  static const Type Any =
    Argument_Type_Any;
  static const Type Indirect =
    Argument_Type_Indirect;
  static const Type Field =
    Argument_Type_Field;
  static inline bool Type_IsValid(int value) {
    return Argument_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Argument_Type_Type_MIN;
  static const Type Type_MAX =
    Argument_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Argument_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Argument_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Argument_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Argument_Type_Parse(name, value);
  }

  typedef Argument_MatchType MatchType;
  static const MatchType Exact =
    Argument_MatchType_Exact;
  static const MatchType Flags =
    Argument_MatchType_Flags;
  static const MatchType Mask =
    Argument_MatchType_Mask;
  static inline bool MatchType_IsValid(int value) {
    return Argument_MatchType_IsValid(value);
  }
  static const MatchType MatchType_MIN =
    Argument_MatchType_MatchType_MIN;
  static const MatchType MatchType_MAX =
    Argument_MatchType_MatchType_MAX;
  static const int MatchType_ARRAYSIZE =
    Argument_MatchType_MatchType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MatchType_descriptor() {
    return Argument_MatchType_descriptor();
  }
  static inline const ::std::string& MatchType_Name(MatchType value) {
    return Argument_MatchType_Name(value);
  }
  static inline bool MatchType_Parse(const ::std::string& name,
      MatchType* value) {
    return Argument_MatchType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .tesla.Argument.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::tesla::Argument_Type type() const;
  void set_type(::tesla::Argument_Type value);

  // optional int32 index = 2;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 2;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional bool free = 9 [default = false];
  bool has_free() const;
  void clear_free();
  static const int kFreeFieldNumber = 9;
  bool free() const;
  void set_free(bool value);

  // optional int64 value = 5;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 5;
  ::google::protobuf::int64 value() const;
  void set_value(::google::protobuf::int64 value);

  // optional .tesla.Argument.MatchType constantMatch = 6 [default = Exact];
  bool has_constantmatch() const;
  void clear_constantmatch();
  static const int kConstantMatchFieldNumber = 6;
  ::tesla::Argument_MatchType constantmatch() const;
  void set_constantmatch(::tesla::Argument_MatchType value);

  // optional .tesla.Argument indirection = 7;
  bool has_indirection() const;
  void clear_indirection();
  static const int kIndirectionFieldNumber = 7;
  const ::tesla::Argument& indirection() const;
  ::tesla::Argument* mutable_indirection();
  ::tesla::Argument* release_indirection();
  void set_allocated_indirection(::tesla::Argument* indirection);

  // optional .tesla.StructField field = 8;
  bool has_field() const;
  void clear_field();
  static const int kFieldFieldNumber = 8;
  const ::tesla::StructField& field() const;
  ::tesla::StructField* mutable_field();
  ::tesla::StructField* release_field();
  void set_allocated_field(::tesla::StructField* field);

  // @@protoc_insertion_point(class_scope:tesla.Argument)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_free();
  inline void clear_has_free();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_constantmatch();
  inline void clear_has_constantmatch();
  inline void set_has_indirection();
  inline void clear_has_indirection();
  inline void set_has_field();
  inline void clear_has_field();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  ::google::protobuf::int32 index_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int64 value_;
  bool free_;
  int constantmatch_;
  ::tesla::Argument* indirection_;
  ::tesla::StructField* field_;
  friend void  protobuf_AddDesc_tesla_2eproto();
  friend void protobuf_AssignDesc_tesla_2eproto();
  friend void protobuf_ShutdownFile_tesla_2eproto();

  void InitAsDefaultInstance();
  static Argument* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ManifestFile

// repeated .tesla.AutomatonDescription automaton = 1;
inline int ManifestFile::automaton_size() const {
  return automaton_.size();
}
inline void ManifestFile::clear_automaton() {
  automaton_.Clear();
}
inline const ::tesla::AutomatonDescription& ManifestFile::automaton(int index) const {
  // @@protoc_insertion_point(field_get:tesla.ManifestFile.automaton)
  return automaton_.Get(index);
}
inline ::tesla::AutomatonDescription* ManifestFile::mutable_automaton(int index) {
  // @@protoc_insertion_point(field_mutable:tesla.ManifestFile.automaton)
  return automaton_.Mutable(index);
}
inline ::tesla::AutomatonDescription* ManifestFile::add_automaton() {
  // @@protoc_insertion_point(field_add:tesla.ManifestFile.automaton)
  return automaton_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tesla::AutomatonDescription >*
ManifestFile::mutable_automaton() {
  // @@protoc_insertion_point(field_mutable_list:tesla.ManifestFile.automaton)
  return &automaton_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tesla::AutomatonDescription >&
ManifestFile::automaton() const {
  // @@protoc_insertion_point(field_list:tesla.ManifestFile.automaton)
  return automaton_;
}

// repeated .tesla.Usage root = 2;
inline int ManifestFile::root_size() const {
  return root_.size();
}
inline void ManifestFile::clear_root() {
  root_.Clear();
}
inline const ::tesla::Usage& ManifestFile::root(int index) const {
  // @@protoc_insertion_point(field_get:tesla.ManifestFile.root)
  return root_.Get(index);
}
inline ::tesla::Usage* ManifestFile::mutable_root(int index) {
  // @@protoc_insertion_point(field_mutable:tesla.ManifestFile.root)
  return root_.Mutable(index);
}
inline ::tesla::Usage* ManifestFile::add_root() {
  // @@protoc_insertion_point(field_add:tesla.ManifestFile.root)
  return root_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tesla::Usage >*
ManifestFile::mutable_root() {
  // @@protoc_insertion_point(field_mutable_list:tesla.ManifestFile.root)
  return &root_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tesla::Usage >&
ManifestFile::root() const {
  // @@protoc_insertion_point(field_list:tesla.ManifestFile.root)
  return root_;
}

// -------------------------------------------------------------------

// Usage

// required .tesla.Identifier identifier = 1;
inline bool Usage::has_identifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Usage::set_has_identifier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Usage::clear_has_identifier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Usage::clear_identifier() {
  if (identifier_ != NULL) identifier_->::tesla::Identifier::Clear();
  clear_has_identifier();
}
inline const ::tesla::Identifier& Usage::identifier() const {
  // @@protoc_insertion_point(field_get:tesla.Usage.identifier)
  return identifier_ != NULL ? *identifier_ : *default_instance_->identifier_;
}
inline ::tesla::Identifier* Usage::mutable_identifier() {
  set_has_identifier();
  if (identifier_ == NULL) {
    identifier_ = new ::tesla::Identifier;
  }
  // @@protoc_insertion_point(field_mutable:tesla.Usage.identifier)
  return identifier_;
}
inline ::tesla::Identifier* Usage::release_identifier() {
  // @@protoc_insertion_point(field_release:tesla.Usage.identifier)
  clear_has_identifier();
  ::tesla::Identifier* temp = identifier_;
  identifier_ = NULL;
  return temp;
}
inline void Usage::set_allocated_identifier(::tesla::Identifier* identifier) {
  delete identifier_;
  identifier_ = identifier;
  if (identifier) {
    set_has_identifier();
  } else {
    clear_has_identifier();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.Usage.identifier)
}

// required uint64 uniqueId = 2;
inline bool Usage::has_uniqueid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Usage::set_has_uniqueid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Usage::clear_has_uniqueid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Usage::clear_uniqueid() {
  uniqueid_ = GOOGLE_ULONGLONG(0);
  clear_has_uniqueid();
}
inline ::google::protobuf::uint64 Usage::uniqueid() const {
  // @@protoc_insertion_point(field_get:tesla.Usage.uniqueId)
  return uniqueid_;
}
inline void Usage::set_uniqueid(::google::protobuf::uint64 value) {
  set_has_uniqueid();
  uniqueid_ = value;
  // @@protoc_insertion_point(field_set:tesla.Usage.uniqueId)
}

// optional .tesla.Expression beginning = 3;
inline bool Usage::has_beginning() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Usage::set_has_beginning() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Usage::clear_has_beginning() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Usage::clear_beginning() {
  if (beginning_ != NULL) beginning_->::tesla::Expression::Clear();
  clear_has_beginning();
}
inline const ::tesla::Expression& Usage::beginning() const {
  // @@protoc_insertion_point(field_get:tesla.Usage.beginning)
  return beginning_ != NULL ? *beginning_ : *default_instance_->beginning_;
}
inline ::tesla::Expression* Usage::mutable_beginning() {
  set_has_beginning();
  if (beginning_ == NULL) {
    beginning_ = new ::tesla::Expression;
  }
  // @@protoc_insertion_point(field_mutable:tesla.Usage.beginning)
  return beginning_;
}
inline ::tesla::Expression* Usage::release_beginning() {
  // @@protoc_insertion_point(field_release:tesla.Usage.beginning)
  clear_has_beginning();
  ::tesla::Expression* temp = beginning_;
  beginning_ = NULL;
  return temp;
}
inline void Usage::set_allocated_beginning(::tesla::Expression* beginning) {
  delete beginning_;
  beginning_ = beginning;
  if (beginning) {
    set_has_beginning();
  } else {
    clear_has_beginning();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.Usage.beginning)
}

// optional .tesla.Expression end = 4;
inline bool Usage::has_end() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Usage::set_has_end() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Usage::clear_has_end() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Usage::clear_end() {
  if (end_ != NULL) end_->::tesla::Expression::Clear();
  clear_has_end();
}
inline const ::tesla::Expression& Usage::end() const {
  // @@protoc_insertion_point(field_get:tesla.Usage.end)
  return end_ != NULL ? *end_ : *default_instance_->end_;
}
inline ::tesla::Expression* Usage::mutable_end() {
  set_has_end();
  if (end_ == NULL) {
    end_ = new ::tesla::Expression;
  }
  // @@protoc_insertion_point(field_mutable:tesla.Usage.end)
  return end_;
}
inline ::tesla::Expression* Usage::release_end() {
  // @@protoc_insertion_point(field_release:tesla.Usage.end)
  clear_has_end();
  ::tesla::Expression* temp = end_;
  end_ = NULL;
  return temp;
}
inline void Usage::set_allocated_end(::tesla::Expression* end) {
  delete end_;
  end_ = end;
  if (end) {
    set_has_end();
  } else {
    clear_has_end();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.Usage.end)
}

// optional bool deleted = 5 [default = false];
inline bool Usage::has_deleted() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Usage::set_has_deleted() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Usage::clear_has_deleted() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Usage::clear_deleted() {
  deleted_ = false;
  clear_has_deleted();
}
inline bool Usage::deleted() const {
  // @@protoc_insertion_point(field_get:tesla.Usage.deleted)
  return deleted_;
}
inline void Usage::set_deleted(bool value) {
  set_has_deleted();
  deleted_ = value;
  // @@protoc_insertion_point(field_set:tesla.Usage.deleted)
}

// -------------------------------------------------------------------

// AutomatonDescription

// required .tesla.Identifier identifier = 1;
inline bool AutomatonDescription::has_identifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AutomatonDescription::set_has_identifier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AutomatonDescription::clear_has_identifier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AutomatonDescription::clear_identifier() {
  if (identifier_ != NULL) identifier_->::tesla::Identifier::Clear();
  clear_has_identifier();
}
inline const ::tesla::Identifier& AutomatonDescription::identifier() const {
  // @@protoc_insertion_point(field_get:tesla.AutomatonDescription.identifier)
  return identifier_ != NULL ? *identifier_ : *default_instance_->identifier_;
}
inline ::tesla::Identifier* AutomatonDescription::mutable_identifier() {
  set_has_identifier();
  if (identifier_ == NULL) {
    identifier_ = new ::tesla::Identifier;
  }
  // @@protoc_insertion_point(field_mutable:tesla.AutomatonDescription.identifier)
  return identifier_;
}
inline ::tesla::Identifier* AutomatonDescription::release_identifier() {
  // @@protoc_insertion_point(field_release:tesla.AutomatonDescription.identifier)
  clear_has_identifier();
  ::tesla::Identifier* temp = identifier_;
  identifier_ = NULL;
  return temp;
}
inline void AutomatonDescription::set_allocated_identifier(::tesla::Identifier* identifier) {
  delete identifier_;
  identifier_ = identifier;
  if (identifier) {
    set_has_identifier();
  } else {
    clear_has_identifier();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.AutomatonDescription.identifier)
}

// required .tesla.AutomatonDescription.Context context = 2;
inline bool AutomatonDescription::has_context() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AutomatonDescription::set_has_context() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AutomatonDescription::clear_has_context() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AutomatonDescription::clear_context() {
  context_ = 1;
  clear_has_context();
}
inline ::tesla::AutomatonDescription_Context AutomatonDescription::context() const {
  // @@protoc_insertion_point(field_get:tesla.AutomatonDescription.context)
  return static_cast< ::tesla::AutomatonDescription_Context >(context_);
}
inline void AutomatonDescription::set_context(::tesla::AutomatonDescription_Context value) {
  assert(::tesla::AutomatonDescription_Context_IsValid(value));
  set_has_context();
  context_ = value;
  // @@protoc_insertion_point(field_set:tesla.AutomatonDescription.context)
}

// required .tesla.Expression expression = 3;
inline bool AutomatonDescription::has_expression() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AutomatonDescription::set_has_expression() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AutomatonDescription::clear_has_expression() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AutomatonDescription::clear_expression() {
  if (expression_ != NULL) expression_->::tesla::Expression::Clear();
  clear_has_expression();
}
inline const ::tesla::Expression& AutomatonDescription::expression() const {
  // @@protoc_insertion_point(field_get:tesla.AutomatonDescription.expression)
  return expression_ != NULL ? *expression_ : *default_instance_->expression_;
}
inline ::tesla::Expression* AutomatonDescription::mutable_expression() {
  set_has_expression();
  if (expression_ == NULL) {
    expression_ = new ::tesla::Expression;
  }
  // @@protoc_insertion_point(field_mutable:tesla.AutomatonDescription.expression)
  return expression_;
}
inline ::tesla::Expression* AutomatonDescription::release_expression() {
  // @@protoc_insertion_point(field_release:tesla.AutomatonDescription.expression)
  clear_has_expression();
  ::tesla::Expression* temp = expression_;
  expression_ = NULL;
  return temp;
}
inline void AutomatonDescription::set_allocated_expression(::tesla::Expression* expression) {
  delete expression_;
  expression_ = expression;
  if (expression) {
    set_has_expression();
  } else {
    clear_has_expression();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.AutomatonDescription.expression)
}

// repeated .tesla.Argument argument = 5;
inline int AutomatonDescription::argument_size() const {
  return argument_.size();
}
inline void AutomatonDescription::clear_argument() {
  argument_.Clear();
}
inline const ::tesla::Argument& AutomatonDescription::argument(int index) const {
  // @@protoc_insertion_point(field_get:tesla.AutomatonDescription.argument)
  return argument_.Get(index);
}
inline ::tesla::Argument* AutomatonDescription::mutable_argument(int index) {
  // @@protoc_insertion_point(field_mutable:tesla.AutomatonDescription.argument)
  return argument_.Mutable(index);
}
inline ::tesla::Argument* AutomatonDescription::add_argument() {
  // @@protoc_insertion_point(field_add:tesla.AutomatonDescription.argument)
  return argument_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tesla::Argument >*
AutomatonDescription::mutable_argument() {
  // @@protoc_insertion_point(field_mutable_list:tesla.AutomatonDescription.argument)
  return &argument_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tesla::Argument >&
AutomatonDescription::argument() const {
  // @@protoc_insertion_point(field_list:tesla.AutomatonDescription.argument)
  return argument_;
}

// optional string source = 6;
inline bool AutomatonDescription::has_source() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AutomatonDescription::set_has_source() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AutomatonDescription::clear_has_source() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AutomatonDescription::clear_source() {
  source_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_source();
}
inline const ::std::string& AutomatonDescription::source() const {
  // @@protoc_insertion_point(field_get:tesla.AutomatonDescription.source)
  return source_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AutomatonDescription::set_source(const ::std::string& value) {
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tesla.AutomatonDescription.source)
}
inline void AutomatonDescription::set_source(const char* value) {
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tesla.AutomatonDescription.source)
}
inline void AutomatonDescription::set_source(const char* value, size_t size) {
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tesla.AutomatonDescription.source)
}
inline ::std::string* AutomatonDescription::mutable_source() {
  set_has_source();
  // @@protoc_insertion_point(field_mutable:tesla.AutomatonDescription.source)
  return source_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AutomatonDescription::release_source() {
  // @@protoc_insertion_point(field_release:tesla.AutomatonDescription.source)
  clear_has_source();
  return source_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AutomatonDescription::set_allocated_source(::std::string* source) {
  if (source != NULL) {
    set_has_source();
  } else {
    clear_has_source();
  }
  source_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source);
  // @@protoc_insertion_point(field_set_allocated:tesla.AutomatonDescription.source)
}

// -------------------------------------------------------------------

// Identifier

// optional string name = 1;
inline bool Identifier::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Identifier::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Identifier::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Identifier::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Identifier::name() const {
  // @@protoc_insertion_point(field_get:tesla.Identifier.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Identifier::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tesla.Identifier.name)
}
inline void Identifier::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tesla.Identifier.name)
}
inline void Identifier::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tesla.Identifier.name)
}
inline ::std::string* Identifier::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:tesla.Identifier.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Identifier::release_name() {
  // @@protoc_insertion_point(field_release:tesla.Identifier.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Identifier::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tesla.Identifier.name)
}

// optional .tesla.Location location = 2;
inline bool Identifier::has_location() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Identifier::set_has_location() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Identifier::clear_has_location() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Identifier::clear_location() {
  if (location_ != NULL) location_->::tesla::Location::Clear();
  clear_has_location();
}
inline const ::tesla::Location& Identifier::location() const {
  // @@protoc_insertion_point(field_get:tesla.Identifier.location)
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::tesla::Location* Identifier::mutable_location() {
  set_has_location();
  if (location_ == NULL) {
    location_ = new ::tesla::Location;
  }
  // @@protoc_insertion_point(field_mutable:tesla.Identifier.location)
  return location_;
}
inline ::tesla::Location* Identifier::release_location() {
  // @@protoc_insertion_point(field_release:tesla.Identifier.location)
  clear_has_location();
  ::tesla::Location* temp = location_;
  location_ = NULL;
  return temp;
}
inline void Identifier::set_allocated_location(::tesla::Location* location) {
  delete location_;
  location_ = location;
  if (location) {
    set_has_location();
  } else {
    clear_has_location();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.Identifier.location)
}

// -------------------------------------------------------------------

// Location

// required string filename = 1;
inline bool Location::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Location::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Location::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Location::clear_filename() {
  filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_filename();
}
inline const ::std::string& Location::filename() const {
  // @@protoc_insertion_point(field_get:tesla.Location.filename)
  return filename_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Location::set_filename(const ::std::string& value) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tesla.Location.filename)
}
inline void Location::set_filename(const char* value) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tesla.Location.filename)
}
inline void Location::set_filename(const char* value, size_t size) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tesla.Location.filename)
}
inline ::std::string* Location::mutable_filename() {
  set_has_filename();
  // @@protoc_insertion_point(field_mutable:tesla.Location.filename)
  return filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Location::release_filename() {
  // @@protoc_insertion_point(field_release:tesla.Location.filename)
  clear_has_filename();
  return filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Location::set_allocated_filename(::std::string* filename) {
  if (filename != NULL) {
    set_has_filename();
  } else {
    clear_has_filename();
  }
  filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:tesla.Location.filename)
}

// required int32 line = 2;
inline bool Location::has_line() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Location::set_has_line() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Location::clear_has_line() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Location::clear_line() {
  line_ = 0;
  clear_has_line();
}
inline ::google::protobuf::int32 Location::line() const {
  // @@protoc_insertion_point(field_get:tesla.Location.line)
  return line_;
}
inline void Location::set_line(::google::protobuf::int32 value) {
  set_has_line();
  line_ = value;
  // @@protoc_insertion_point(field_set:tesla.Location.line)
}

// required int32 counter = 3;
inline bool Location::has_counter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Location::set_has_counter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Location::clear_has_counter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Location::clear_counter() {
  counter_ = 0;
  clear_has_counter();
}
inline ::google::protobuf::int32 Location::counter() const {
  // @@protoc_insertion_point(field_get:tesla.Location.counter)
  return counter_;
}
inline void Location::set_counter(::google::protobuf::int32 value) {
  set_has_counter();
  counter_ = value;
  // @@protoc_insertion_point(field_set:tesla.Location.counter)
}

// -------------------------------------------------------------------

// Expression

// required .tesla.Expression.Type type = 1;
inline bool Expression::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Expression::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Expression::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Expression::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::tesla::Expression_Type Expression::type() const {
  // @@protoc_insertion_point(field_get:tesla.Expression.type)
  return static_cast< ::tesla::Expression_Type >(type_);
}
inline void Expression::set_type(::tesla::Expression_Type value) {
  assert(::tesla::Expression_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:tesla.Expression.type)
}

// optional .tesla.BooleanExpr booleanExpr = 2;
inline bool Expression::has_booleanexpr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Expression::set_has_booleanexpr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Expression::clear_has_booleanexpr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Expression::clear_booleanexpr() {
  if (booleanexpr_ != NULL) booleanexpr_->::tesla::BooleanExpr::Clear();
  clear_has_booleanexpr();
}
inline const ::tesla::BooleanExpr& Expression::booleanexpr() const {
  // @@protoc_insertion_point(field_get:tesla.Expression.booleanExpr)
  return booleanexpr_ != NULL ? *booleanexpr_ : *default_instance_->booleanexpr_;
}
inline ::tesla::BooleanExpr* Expression::mutable_booleanexpr() {
  set_has_booleanexpr();
  if (booleanexpr_ == NULL) {
    booleanexpr_ = new ::tesla::BooleanExpr;
  }
  // @@protoc_insertion_point(field_mutable:tesla.Expression.booleanExpr)
  return booleanexpr_;
}
inline ::tesla::BooleanExpr* Expression::release_booleanexpr() {
  // @@protoc_insertion_point(field_release:tesla.Expression.booleanExpr)
  clear_has_booleanexpr();
  ::tesla::BooleanExpr* temp = booleanexpr_;
  booleanexpr_ = NULL;
  return temp;
}
inline void Expression::set_allocated_booleanexpr(::tesla::BooleanExpr* booleanexpr) {
  delete booleanexpr_;
  booleanexpr_ = booleanexpr;
  if (booleanexpr) {
    set_has_booleanexpr();
  } else {
    clear_has_booleanexpr();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.Expression.booleanExpr)
}

// optional .tesla.Sequence sequence = 3;
inline bool Expression::has_sequence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Expression::set_has_sequence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Expression::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Expression::clear_sequence() {
  if (sequence_ != NULL) sequence_->::tesla::Sequence::Clear();
  clear_has_sequence();
}
inline const ::tesla::Sequence& Expression::sequence() const {
  // @@protoc_insertion_point(field_get:tesla.Expression.sequence)
  return sequence_ != NULL ? *sequence_ : *default_instance_->sequence_;
}
inline ::tesla::Sequence* Expression::mutable_sequence() {
  set_has_sequence();
  if (sequence_ == NULL) {
    sequence_ = new ::tesla::Sequence;
  }
  // @@protoc_insertion_point(field_mutable:tesla.Expression.sequence)
  return sequence_;
}
inline ::tesla::Sequence* Expression::release_sequence() {
  // @@protoc_insertion_point(field_release:tesla.Expression.sequence)
  clear_has_sequence();
  ::tesla::Sequence* temp = sequence_;
  sequence_ = NULL;
  return temp;
}
inline void Expression::set_allocated_sequence(::tesla::Sequence* sequence) {
  delete sequence_;
  sequence_ = sequence;
  if (sequence) {
    set_has_sequence();
  } else {
    clear_has_sequence();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.Expression.sequence)
}

// optional .tesla.AssertionSite assertSite = 4;
inline bool Expression::has_assertsite() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Expression::set_has_assertsite() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Expression::clear_has_assertsite() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Expression::clear_assertsite() {
  if (assertsite_ != NULL) assertsite_->::tesla::AssertionSite::Clear();
  clear_has_assertsite();
}
inline const ::tesla::AssertionSite& Expression::assertsite() const {
  // @@protoc_insertion_point(field_get:tesla.Expression.assertSite)
  return assertsite_ != NULL ? *assertsite_ : *default_instance_->assertsite_;
}
inline ::tesla::AssertionSite* Expression::mutable_assertsite() {
  set_has_assertsite();
  if (assertsite_ == NULL) {
    assertsite_ = new ::tesla::AssertionSite;
  }
  // @@protoc_insertion_point(field_mutable:tesla.Expression.assertSite)
  return assertsite_;
}
inline ::tesla::AssertionSite* Expression::release_assertsite() {
  // @@protoc_insertion_point(field_release:tesla.Expression.assertSite)
  clear_has_assertsite();
  ::tesla::AssertionSite* temp = assertsite_;
  assertsite_ = NULL;
  return temp;
}
inline void Expression::set_allocated_assertsite(::tesla::AssertionSite* assertsite) {
  delete assertsite_;
  assertsite_ = assertsite;
  if (assertsite) {
    set_has_assertsite();
  } else {
    clear_has_assertsite();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.Expression.assertSite)
}

// optional .tesla.FunctionEvent function = 5;
inline bool Expression::has_function() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Expression::set_has_function() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Expression::clear_has_function() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Expression::clear_function() {
  if (function_ != NULL) function_->::tesla::FunctionEvent::Clear();
  clear_has_function();
}
inline const ::tesla::FunctionEvent& Expression::function() const {
  // @@protoc_insertion_point(field_get:tesla.Expression.function)
  return function_ != NULL ? *function_ : *default_instance_->function_;
}
inline ::tesla::FunctionEvent* Expression::mutable_function() {
  set_has_function();
  if (function_ == NULL) {
    function_ = new ::tesla::FunctionEvent;
  }
  // @@protoc_insertion_point(field_mutable:tesla.Expression.function)
  return function_;
}
inline ::tesla::FunctionEvent* Expression::release_function() {
  // @@protoc_insertion_point(field_release:tesla.Expression.function)
  clear_has_function();
  ::tesla::FunctionEvent* temp = function_;
  function_ = NULL;
  return temp;
}
inline void Expression::set_allocated_function(::tesla::FunctionEvent* function) {
  delete function_;
  function_ = function;
  if (function) {
    set_has_function();
  } else {
    clear_has_function();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.Expression.function)
}

// optional .tesla.FieldAssignment fieldAssign = 6;
inline bool Expression::has_fieldassign() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Expression::set_has_fieldassign() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Expression::clear_has_fieldassign() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Expression::clear_fieldassign() {
  if (fieldassign_ != NULL) fieldassign_->::tesla::FieldAssignment::Clear();
  clear_has_fieldassign();
}
inline const ::tesla::FieldAssignment& Expression::fieldassign() const {
  // @@protoc_insertion_point(field_get:tesla.Expression.fieldAssign)
  return fieldassign_ != NULL ? *fieldassign_ : *default_instance_->fieldassign_;
}
inline ::tesla::FieldAssignment* Expression::mutable_fieldassign() {
  set_has_fieldassign();
  if (fieldassign_ == NULL) {
    fieldassign_ = new ::tesla::FieldAssignment;
  }
  // @@protoc_insertion_point(field_mutable:tesla.Expression.fieldAssign)
  return fieldassign_;
}
inline ::tesla::FieldAssignment* Expression::release_fieldassign() {
  // @@protoc_insertion_point(field_release:tesla.Expression.fieldAssign)
  clear_has_fieldassign();
  ::tesla::FieldAssignment* temp = fieldassign_;
  fieldassign_ = NULL;
  return temp;
}
inline void Expression::set_allocated_fieldassign(::tesla::FieldAssignment* fieldassign) {
  delete fieldassign_;
  fieldassign_ = fieldassign;
  if (fieldassign) {
    set_has_fieldassign();
  } else {
    clear_has_fieldassign();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.Expression.fieldAssign)
}

// optional .tesla.Identifier subAutomaton = 7;
inline bool Expression::has_subautomaton() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Expression::set_has_subautomaton() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Expression::clear_has_subautomaton() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Expression::clear_subautomaton() {
  if (subautomaton_ != NULL) subautomaton_->::tesla::Identifier::Clear();
  clear_has_subautomaton();
}
inline const ::tesla::Identifier& Expression::subautomaton() const {
  // @@protoc_insertion_point(field_get:tesla.Expression.subAutomaton)
  return subautomaton_ != NULL ? *subautomaton_ : *default_instance_->subautomaton_;
}
inline ::tesla::Identifier* Expression::mutable_subautomaton() {
  set_has_subautomaton();
  if (subautomaton_ == NULL) {
    subautomaton_ = new ::tesla::Identifier;
  }
  // @@protoc_insertion_point(field_mutable:tesla.Expression.subAutomaton)
  return subautomaton_;
}
inline ::tesla::Identifier* Expression::release_subautomaton() {
  // @@protoc_insertion_point(field_release:tesla.Expression.subAutomaton)
  clear_has_subautomaton();
  ::tesla::Identifier* temp = subautomaton_;
  subautomaton_ = NULL;
  return temp;
}
inline void Expression::set_allocated_subautomaton(::tesla::Identifier* subautomaton) {
  delete subautomaton_;
  subautomaton_ = subautomaton;
  if (subautomaton) {
    set_has_subautomaton();
  } else {
    clear_has_subautomaton();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.Expression.subAutomaton)
}

// -------------------------------------------------------------------

// BooleanExpr

// required .tesla.BooleanExpr.Operation operation = 1;
inline bool BooleanExpr::has_operation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BooleanExpr::set_has_operation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BooleanExpr::clear_has_operation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BooleanExpr::clear_operation() {
  operation_ = 1;
  clear_has_operation();
}
inline ::tesla::BooleanExpr_Operation BooleanExpr::operation() const {
  // @@protoc_insertion_point(field_get:tesla.BooleanExpr.operation)
  return static_cast< ::tesla::BooleanExpr_Operation >(operation_);
}
inline void BooleanExpr::set_operation(::tesla::BooleanExpr_Operation value) {
  assert(::tesla::BooleanExpr_Operation_IsValid(value));
  set_has_operation();
  operation_ = value;
  // @@protoc_insertion_point(field_set:tesla.BooleanExpr.operation)
}

// repeated .tesla.Expression expression = 2;
inline int BooleanExpr::expression_size() const {
  return expression_.size();
}
inline void BooleanExpr::clear_expression() {
  expression_.Clear();
}
inline const ::tesla::Expression& BooleanExpr::expression(int index) const {
  // @@protoc_insertion_point(field_get:tesla.BooleanExpr.expression)
  return expression_.Get(index);
}
inline ::tesla::Expression* BooleanExpr::mutable_expression(int index) {
  // @@protoc_insertion_point(field_mutable:tesla.BooleanExpr.expression)
  return expression_.Mutable(index);
}
inline ::tesla::Expression* BooleanExpr::add_expression() {
  // @@protoc_insertion_point(field_add:tesla.BooleanExpr.expression)
  return expression_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tesla::Expression >*
BooleanExpr::mutable_expression() {
  // @@protoc_insertion_point(field_mutable_list:tesla.BooleanExpr.expression)
  return &expression_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tesla::Expression >&
BooleanExpr::expression() const {
  // @@protoc_insertion_point(field_list:tesla.BooleanExpr.expression)
  return expression_;
}

// -------------------------------------------------------------------

// Sequence

// repeated .tesla.Expression expression = 1;
inline int Sequence::expression_size() const {
  return expression_.size();
}
inline void Sequence::clear_expression() {
  expression_.Clear();
}
inline const ::tesla::Expression& Sequence::expression(int index) const {
  // @@protoc_insertion_point(field_get:tesla.Sequence.expression)
  return expression_.Get(index);
}
inline ::tesla::Expression* Sequence::mutable_expression(int index) {
  // @@protoc_insertion_point(field_mutable:tesla.Sequence.expression)
  return expression_.Mutable(index);
}
inline ::tesla::Expression* Sequence::add_expression() {
  // @@protoc_insertion_point(field_add:tesla.Sequence.expression)
  return expression_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tesla::Expression >*
Sequence::mutable_expression() {
  // @@protoc_insertion_point(field_mutable_list:tesla.Sequence.expression)
  return &expression_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tesla::Expression >&
Sequence::expression() const {
  // @@protoc_insertion_point(field_list:tesla.Sequence.expression)
  return expression_;
}

// optional int32 minReps = 2 [default = 1];
inline bool Sequence::has_minreps() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Sequence::set_has_minreps() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Sequence::clear_has_minreps() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Sequence::clear_minreps() {
  minreps_ = 1;
  clear_has_minreps();
}
inline ::google::protobuf::int32 Sequence::minreps() const {
  // @@protoc_insertion_point(field_get:tesla.Sequence.minReps)
  return minreps_;
}
inline void Sequence::set_minreps(::google::protobuf::int32 value) {
  set_has_minreps();
  minreps_ = value;
  // @@protoc_insertion_point(field_set:tesla.Sequence.minReps)
}

// optional int32 maxReps = 3 [default = 1];
inline bool Sequence::has_maxreps() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Sequence::set_has_maxreps() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Sequence::clear_has_maxreps() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Sequence::clear_maxreps() {
  maxreps_ = 1;
  clear_has_maxreps();
}
inline ::google::protobuf::int32 Sequence::maxreps() const {
  // @@protoc_insertion_point(field_get:tesla.Sequence.maxReps)
  return maxreps_;
}
inline void Sequence::set_maxreps(::google::protobuf::int32 value) {
  set_has_maxreps();
  maxreps_ = value;
  // @@protoc_insertion_point(field_set:tesla.Sequence.maxReps)
}

// -------------------------------------------------------------------

// AssertionSite

// required .tesla.Location location = 1;
inline bool AssertionSite::has_location() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AssertionSite::set_has_location() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AssertionSite::clear_has_location() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AssertionSite::clear_location() {
  if (location_ != NULL) location_->::tesla::Location::Clear();
  clear_has_location();
}
inline const ::tesla::Location& AssertionSite::location() const {
  // @@protoc_insertion_point(field_get:tesla.AssertionSite.location)
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::tesla::Location* AssertionSite::mutable_location() {
  set_has_location();
  if (location_ == NULL) {
    location_ = new ::tesla::Location;
  }
  // @@protoc_insertion_point(field_mutable:tesla.AssertionSite.location)
  return location_;
}
inline ::tesla::Location* AssertionSite::release_location() {
  // @@protoc_insertion_point(field_release:tesla.AssertionSite.location)
  clear_has_location();
  ::tesla::Location* temp = location_;
  location_ = NULL;
  return temp;
}
inline void AssertionSite::set_allocated_location(::tesla::Location* location) {
  delete location_;
  location_ = location;
  if (location) {
    set_has_location();
  } else {
    clear_has_location();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.AssertionSite.location)
}

// optional .tesla.FunctionRef function = 2;
inline bool AssertionSite::has_function() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AssertionSite::set_has_function() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AssertionSite::clear_has_function() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AssertionSite::clear_function() {
  if (function_ != NULL) function_->::tesla::FunctionRef::Clear();
  clear_has_function();
}
inline const ::tesla::FunctionRef& AssertionSite::function() const {
  // @@protoc_insertion_point(field_get:tesla.AssertionSite.function)
  return function_ != NULL ? *function_ : *default_instance_->function_;
}
inline ::tesla::FunctionRef* AssertionSite::mutable_function() {
  set_has_function();
  if (function_ == NULL) {
    function_ = new ::tesla::FunctionRef;
  }
  // @@protoc_insertion_point(field_mutable:tesla.AssertionSite.function)
  return function_;
}
inline ::tesla::FunctionRef* AssertionSite::release_function() {
  // @@protoc_insertion_point(field_release:tesla.AssertionSite.function)
  clear_has_function();
  ::tesla::FunctionRef* temp = function_;
  function_ = NULL;
  return temp;
}
inline void AssertionSite::set_allocated_function(::tesla::FunctionRef* function) {
  delete function_;
  function_ = function;
  if (function) {
    set_has_function();
  } else {
    clear_has_function();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.AssertionSite.function)
}

// -------------------------------------------------------------------

// FunctionEvent

// required .tesla.FunctionRef function = 1;
inline bool FunctionEvent::has_function() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FunctionEvent::set_has_function() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FunctionEvent::clear_has_function() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FunctionEvent::clear_function() {
  if (function_ != NULL) function_->::tesla::FunctionRef::Clear();
  clear_has_function();
}
inline const ::tesla::FunctionRef& FunctionEvent::function() const {
  // @@protoc_insertion_point(field_get:tesla.FunctionEvent.function)
  return function_ != NULL ? *function_ : *default_instance_->function_;
}
inline ::tesla::FunctionRef* FunctionEvent::mutable_function() {
  set_has_function();
  if (function_ == NULL) {
    function_ = new ::tesla::FunctionRef;
  }
  // @@protoc_insertion_point(field_mutable:tesla.FunctionEvent.function)
  return function_;
}
inline ::tesla::FunctionRef* FunctionEvent::release_function() {
  // @@protoc_insertion_point(field_release:tesla.FunctionEvent.function)
  clear_has_function();
  ::tesla::FunctionRef* temp = function_;
  function_ = NULL;
  return temp;
}
inline void FunctionEvent::set_allocated_function(::tesla::FunctionRef* function) {
  delete function_;
  function_ = function;
  if (function) {
    set_has_function();
  } else {
    clear_has_function();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.FunctionEvent.function)
}

// optional .tesla.FunctionEvent.Direction direction = 2;
inline bool FunctionEvent::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FunctionEvent::set_has_direction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FunctionEvent::clear_has_direction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FunctionEvent::clear_direction() {
  direction_ = 1;
  clear_has_direction();
}
inline ::tesla::FunctionEvent_Direction FunctionEvent::direction() const {
  // @@protoc_insertion_point(field_get:tesla.FunctionEvent.direction)
  return static_cast< ::tesla::FunctionEvent_Direction >(direction_);
}
inline void FunctionEvent::set_direction(::tesla::FunctionEvent_Direction value) {
  assert(::tesla::FunctionEvent_Direction_IsValid(value));
  set_has_direction();
  direction_ = value;
  // @@protoc_insertion_point(field_set:tesla.FunctionEvent.direction)
}

// optional .tesla.FunctionEvent.CallContext context = 3;
inline bool FunctionEvent::has_context() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FunctionEvent::set_has_context() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FunctionEvent::clear_has_context() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FunctionEvent::clear_context() {
  context_ = 1;
  clear_has_context();
}
inline ::tesla::FunctionEvent_CallContext FunctionEvent::context() const {
  // @@protoc_insertion_point(field_get:tesla.FunctionEvent.context)
  return static_cast< ::tesla::FunctionEvent_CallContext >(context_);
}
inline void FunctionEvent::set_context(::tesla::FunctionEvent_CallContext value) {
  assert(::tesla::FunctionEvent_CallContext_IsValid(value));
  set_has_context();
  context_ = value;
  // @@protoc_insertion_point(field_set:tesla.FunctionEvent.context)
}

// repeated .tesla.Argument argument = 4;
inline int FunctionEvent::argument_size() const {
  return argument_.size();
}
inline void FunctionEvent::clear_argument() {
  argument_.Clear();
}
inline const ::tesla::Argument& FunctionEvent::argument(int index) const {
  // @@protoc_insertion_point(field_get:tesla.FunctionEvent.argument)
  return argument_.Get(index);
}
inline ::tesla::Argument* FunctionEvent::mutable_argument(int index) {
  // @@protoc_insertion_point(field_mutable:tesla.FunctionEvent.argument)
  return argument_.Mutable(index);
}
inline ::tesla::Argument* FunctionEvent::add_argument() {
  // @@protoc_insertion_point(field_add:tesla.FunctionEvent.argument)
  return argument_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tesla::Argument >*
FunctionEvent::mutable_argument() {
  // @@protoc_insertion_point(field_mutable_list:tesla.FunctionEvent.argument)
  return &argument_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tesla::Argument >&
FunctionEvent::argument() const {
  // @@protoc_insertion_point(field_list:tesla.FunctionEvent.argument)
  return argument_;
}

// optional .tesla.Argument expectedReturnValue = 5;
inline bool FunctionEvent::has_expectedreturnvalue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FunctionEvent::set_has_expectedreturnvalue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FunctionEvent::clear_has_expectedreturnvalue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FunctionEvent::clear_expectedreturnvalue() {
  if (expectedreturnvalue_ != NULL) expectedreturnvalue_->::tesla::Argument::Clear();
  clear_has_expectedreturnvalue();
}
inline const ::tesla::Argument& FunctionEvent::expectedreturnvalue() const {
  // @@protoc_insertion_point(field_get:tesla.FunctionEvent.expectedReturnValue)
  return expectedreturnvalue_ != NULL ? *expectedreturnvalue_ : *default_instance_->expectedreturnvalue_;
}
inline ::tesla::Argument* FunctionEvent::mutable_expectedreturnvalue() {
  set_has_expectedreturnvalue();
  if (expectedreturnvalue_ == NULL) {
    expectedreturnvalue_ = new ::tesla::Argument;
  }
  // @@protoc_insertion_point(field_mutable:tesla.FunctionEvent.expectedReturnValue)
  return expectedreturnvalue_;
}
inline ::tesla::Argument* FunctionEvent::release_expectedreturnvalue() {
  // @@protoc_insertion_point(field_release:tesla.FunctionEvent.expectedReturnValue)
  clear_has_expectedreturnvalue();
  ::tesla::Argument* temp = expectedreturnvalue_;
  expectedreturnvalue_ = NULL;
  return temp;
}
inline void FunctionEvent::set_allocated_expectedreturnvalue(::tesla::Argument* expectedreturnvalue) {
  delete expectedreturnvalue_;
  expectedreturnvalue_ = expectedreturnvalue;
  if (expectedreturnvalue) {
    set_has_expectedreturnvalue();
  } else {
    clear_has_expectedreturnvalue();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.FunctionEvent.expectedReturnValue)
}

// optional bool strict = 6 [default = true];
inline bool FunctionEvent::has_strict() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FunctionEvent::set_has_strict() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FunctionEvent::clear_has_strict() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FunctionEvent::clear_strict() {
  strict_ = true;
  clear_has_strict();
}
inline bool FunctionEvent::strict() const {
  // @@protoc_insertion_point(field_get:tesla.FunctionEvent.strict)
  return strict_;
}
inline void FunctionEvent::set_strict(bool value) {
  set_has_strict();
  strict_ = value;
  // @@protoc_insertion_point(field_set:tesla.FunctionEvent.strict)
}

// optional .tesla.FunctionEvent.CallKind kind = 7 [default = CCall];
inline bool FunctionEvent::has_kind() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FunctionEvent::set_has_kind() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FunctionEvent::clear_has_kind() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FunctionEvent::clear_kind() {
  kind_ = 1;
  clear_has_kind();
}
inline ::tesla::FunctionEvent_CallKind FunctionEvent::kind() const {
  // @@protoc_insertion_point(field_get:tesla.FunctionEvent.kind)
  return static_cast< ::tesla::FunctionEvent_CallKind >(kind_);
}
inline void FunctionEvent::set_kind(::tesla::FunctionEvent_CallKind value) {
  assert(::tesla::FunctionEvent_CallKind_IsValid(value));
  set_has_kind();
  kind_ = value;
  // @@protoc_insertion_point(field_set:tesla.FunctionEvent.kind)
}

// optional .tesla.Argument receiver = 8;
inline bool FunctionEvent::has_receiver() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FunctionEvent::set_has_receiver() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FunctionEvent::clear_has_receiver() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FunctionEvent::clear_receiver() {
  if (receiver_ != NULL) receiver_->::tesla::Argument::Clear();
  clear_has_receiver();
}
inline const ::tesla::Argument& FunctionEvent::receiver() const {
  // @@protoc_insertion_point(field_get:tesla.FunctionEvent.receiver)
  return receiver_ != NULL ? *receiver_ : *default_instance_->receiver_;
}
inline ::tesla::Argument* FunctionEvent::mutable_receiver() {
  set_has_receiver();
  if (receiver_ == NULL) {
    receiver_ = new ::tesla::Argument;
  }
  // @@protoc_insertion_point(field_mutable:tesla.FunctionEvent.receiver)
  return receiver_;
}
inline ::tesla::Argument* FunctionEvent::release_receiver() {
  // @@protoc_insertion_point(field_release:tesla.FunctionEvent.receiver)
  clear_has_receiver();
  ::tesla::Argument* temp = receiver_;
  receiver_ = NULL;
  return temp;
}
inline void FunctionEvent::set_allocated_receiver(::tesla::Argument* receiver) {
  delete receiver_;
  receiver_ = receiver;
  if (receiver) {
    set_has_receiver();
  } else {
    clear_has_receiver();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.FunctionEvent.receiver)
}

// -------------------------------------------------------------------

// FunctionRef

// required string name = 1;
inline bool FunctionRef::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FunctionRef::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FunctionRef::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FunctionRef::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& FunctionRef::name() const {
  // @@protoc_insertion_point(field_get:tesla.FunctionRef.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FunctionRef::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tesla.FunctionRef.name)
}
inline void FunctionRef::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tesla.FunctionRef.name)
}
inline void FunctionRef::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tesla.FunctionRef.name)
}
inline ::std::string* FunctionRef::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:tesla.FunctionRef.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FunctionRef::release_name() {
  // @@protoc_insertion_point(field_release:tesla.FunctionRef.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FunctionRef::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tesla.FunctionRef.name)
}

// -------------------------------------------------------------------

// FieldAssignment

// required .tesla.StructField field = 8;
inline bool FieldAssignment::has_field() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FieldAssignment::set_has_field() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FieldAssignment::clear_has_field() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FieldAssignment::clear_field() {
  if (field_ != NULL) field_->::tesla::StructField::Clear();
  clear_has_field();
}
inline const ::tesla::StructField& FieldAssignment::field() const {
  // @@protoc_insertion_point(field_get:tesla.FieldAssignment.field)
  return field_ != NULL ? *field_ : *default_instance_->field_;
}
inline ::tesla::StructField* FieldAssignment::mutable_field() {
  set_has_field();
  if (field_ == NULL) {
    field_ = new ::tesla::StructField;
  }
  // @@protoc_insertion_point(field_mutable:tesla.FieldAssignment.field)
  return field_;
}
inline ::tesla::StructField* FieldAssignment::release_field() {
  // @@protoc_insertion_point(field_release:tesla.FieldAssignment.field)
  clear_has_field();
  ::tesla::StructField* temp = field_;
  field_ = NULL;
  return temp;
}
inline void FieldAssignment::set_allocated_field(::tesla::StructField* field) {
  delete field_;
  field_ = field;
  if (field) {
    set_has_field();
  } else {
    clear_has_field();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.FieldAssignment.field)
}

// required .tesla.FieldAssignment.AssignType operation = 4;
inline bool FieldAssignment::has_operation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FieldAssignment::set_has_operation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FieldAssignment::clear_has_operation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FieldAssignment::clear_operation() {
  operation_ = 1;
  clear_has_operation();
}
inline ::tesla::FieldAssignment_AssignType FieldAssignment::operation() const {
  // @@protoc_insertion_point(field_get:tesla.FieldAssignment.operation)
  return static_cast< ::tesla::FieldAssignment_AssignType >(operation_);
}
inline void FieldAssignment::set_operation(::tesla::FieldAssignment_AssignType value) {
  assert(::tesla::FieldAssignment_AssignType_IsValid(value));
  set_has_operation();
  operation_ = value;
  // @@protoc_insertion_point(field_set:tesla.FieldAssignment.operation)
}

// required .tesla.Argument value = 5;
inline bool FieldAssignment::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FieldAssignment::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FieldAssignment::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FieldAssignment::clear_value() {
  if (value_ != NULL) value_->::tesla::Argument::Clear();
  clear_has_value();
}
inline const ::tesla::Argument& FieldAssignment::value() const {
  // @@protoc_insertion_point(field_get:tesla.FieldAssignment.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::tesla::Argument* FieldAssignment::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::tesla::Argument;
  }
  // @@protoc_insertion_point(field_mutable:tesla.FieldAssignment.value)
  return value_;
}
inline ::tesla::Argument* FieldAssignment::release_value() {
  // @@protoc_insertion_point(field_release:tesla.FieldAssignment.value)
  clear_has_value();
  ::tesla::Argument* temp = value_;
  value_ = NULL;
  return temp;
}
inline void FieldAssignment::set_allocated_value(::tesla::Argument* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.FieldAssignment.value)
}

// optional bool strict = 7 [default = true];
inline bool FieldAssignment::has_strict() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FieldAssignment::set_has_strict() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FieldAssignment::clear_has_strict() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FieldAssignment::clear_strict() {
  strict_ = true;
  clear_has_strict();
}
inline bool FieldAssignment::strict() const {
  // @@protoc_insertion_point(field_get:tesla.FieldAssignment.strict)
  return strict_;
}
inline void FieldAssignment::set_strict(bool value) {
  set_has_strict();
  strict_ = value;
  // @@protoc_insertion_point(field_set:tesla.FieldAssignment.strict)
}

// -------------------------------------------------------------------

// StructField

// required string type = 1;
inline bool StructField::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StructField::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StructField::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StructField::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& StructField::type() const {
  // @@protoc_insertion_point(field_get:tesla.StructField.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StructField::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tesla.StructField.type)
}
inline void StructField::set_type(const char* value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tesla.StructField.type)
}
inline void StructField::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tesla.StructField.type)
}
inline ::std::string* StructField::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:tesla.StructField.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StructField::release_type() {
  // @@protoc_insertion_point(field_release:tesla.StructField.type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StructField::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:tesla.StructField.type)
}

// required .tesla.Argument base = 2;
inline bool StructField::has_base() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StructField::set_has_base() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StructField::clear_has_base() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StructField::clear_base() {
  if (base_ != NULL) base_->::tesla::Argument::Clear();
  clear_has_base();
}
inline const ::tesla::Argument& StructField::base() const {
  // @@protoc_insertion_point(field_get:tesla.StructField.base)
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::tesla::Argument* StructField::mutable_base() {
  set_has_base();
  if (base_ == NULL) {
    base_ = new ::tesla::Argument;
  }
  // @@protoc_insertion_point(field_mutable:tesla.StructField.base)
  return base_;
}
inline ::tesla::Argument* StructField::release_base() {
  // @@protoc_insertion_point(field_release:tesla.StructField.base)
  clear_has_base();
  ::tesla::Argument* temp = base_;
  base_ = NULL;
  return temp;
}
inline void StructField::set_allocated_base(::tesla::Argument* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.StructField.base)
}

// required string name = 3;
inline bool StructField::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StructField::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StructField::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StructField::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& StructField::name() const {
  // @@protoc_insertion_point(field_get:tesla.StructField.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StructField::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tesla.StructField.name)
}
inline void StructField::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tesla.StructField.name)
}
inline void StructField::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tesla.StructField.name)
}
inline ::std::string* StructField::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:tesla.StructField.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StructField::release_name() {
  // @@protoc_insertion_point(field_release:tesla.StructField.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StructField::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tesla.StructField.name)
}

// required int32 index = 4;
inline bool StructField::has_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StructField::set_has_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StructField::clear_has_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StructField::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 StructField::index() const {
  // @@protoc_insertion_point(field_get:tesla.StructField.index)
  return index_;
}
inline void StructField::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:tesla.StructField.index)
}

// -------------------------------------------------------------------

// Argument

// required .tesla.Argument.Type type = 1;
inline bool Argument::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Argument::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Argument::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Argument::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::tesla::Argument_Type Argument::type() const {
  // @@protoc_insertion_point(field_get:tesla.Argument.type)
  return static_cast< ::tesla::Argument_Type >(type_);
}
inline void Argument::set_type(::tesla::Argument_Type value) {
  assert(::tesla::Argument_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:tesla.Argument.type)
}

// optional int32 index = 2;
inline bool Argument::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Argument::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Argument::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Argument::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 Argument::index() const {
  // @@protoc_insertion_point(field_get:tesla.Argument.index)
  return index_;
}
inline void Argument::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:tesla.Argument.index)
}

// optional string name = 3;
inline bool Argument::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Argument::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Argument::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Argument::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Argument::name() const {
  // @@protoc_insertion_point(field_get:tesla.Argument.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Argument::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tesla.Argument.name)
}
inline void Argument::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tesla.Argument.name)
}
inline void Argument::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tesla.Argument.name)
}
inline ::std::string* Argument::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:tesla.Argument.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Argument::release_name() {
  // @@protoc_insertion_point(field_release:tesla.Argument.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Argument::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tesla.Argument.name)
}

// optional bool free = 9 [default = false];
inline bool Argument::has_free() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Argument::set_has_free() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Argument::clear_has_free() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Argument::clear_free() {
  free_ = false;
  clear_has_free();
}
inline bool Argument::free() const {
  // @@protoc_insertion_point(field_get:tesla.Argument.free)
  return free_;
}
inline void Argument::set_free(bool value) {
  set_has_free();
  free_ = value;
  // @@protoc_insertion_point(field_set:tesla.Argument.free)
}

// optional int64 value = 5;
inline bool Argument::has_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Argument::set_has_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Argument::clear_has_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Argument::clear_value() {
  value_ = GOOGLE_LONGLONG(0);
  clear_has_value();
}
inline ::google::protobuf::int64 Argument::value() const {
  // @@protoc_insertion_point(field_get:tesla.Argument.value)
  return value_;
}
inline void Argument::set_value(::google::protobuf::int64 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:tesla.Argument.value)
}

// optional .tesla.Argument.MatchType constantMatch = 6 [default = Exact];
inline bool Argument::has_constantmatch() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Argument::set_has_constantmatch() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Argument::clear_has_constantmatch() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Argument::clear_constantmatch() {
  constantmatch_ = 1;
  clear_has_constantmatch();
}
inline ::tesla::Argument_MatchType Argument::constantmatch() const {
  // @@protoc_insertion_point(field_get:tesla.Argument.constantMatch)
  return static_cast< ::tesla::Argument_MatchType >(constantmatch_);
}
inline void Argument::set_constantmatch(::tesla::Argument_MatchType value) {
  assert(::tesla::Argument_MatchType_IsValid(value));
  set_has_constantmatch();
  constantmatch_ = value;
  // @@protoc_insertion_point(field_set:tesla.Argument.constantMatch)
}

// optional .tesla.Argument indirection = 7;
inline bool Argument::has_indirection() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Argument::set_has_indirection() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Argument::clear_has_indirection() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Argument::clear_indirection() {
  if (indirection_ != NULL) indirection_->::tesla::Argument::Clear();
  clear_has_indirection();
}
inline const ::tesla::Argument& Argument::indirection() const {
  // @@protoc_insertion_point(field_get:tesla.Argument.indirection)
  return indirection_ != NULL ? *indirection_ : *default_instance_->indirection_;
}
inline ::tesla::Argument* Argument::mutable_indirection() {
  set_has_indirection();
  if (indirection_ == NULL) {
    indirection_ = new ::tesla::Argument;
  }
  // @@protoc_insertion_point(field_mutable:tesla.Argument.indirection)
  return indirection_;
}
inline ::tesla::Argument* Argument::release_indirection() {
  // @@protoc_insertion_point(field_release:tesla.Argument.indirection)
  clear_has_indirection();
  ::tesla::Argument* temp = indirection_;
  indirection_ = NULL;
  return temp;
}
inline void Argument::set_allocated_indirection(::tesla::Argument* indirection) {
  delete indirection_;
  indirection_ = indirection;
  if (indirection) {
    set_has_indirection();
  } else {
    clear_has_indirection();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.Argument.indirection)
}

// optional .tesla.StructField field = 8;
inline bool Argument::has_field() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Argument::set_has_field() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Argument::clear_has_field() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Argument::clear_field() {
  if (field_ != NULL) field_->::tesla::StructField::Clear();
  clear_has_field();
}
inline const ::tesla::StructField& Argument::field() const {
  // @@protoc_insertion_point(field_get:tesla.Argument.field)
  return field_ != NULL ? *field_ : *default_instance_->field_;
}
inline ::tesla::StructField* Argument::mutable_field() {
  set_has_field();
  if (field_ == NULL) {
    field_ = new ::tesla::StructField;
  }
  // @@protoc_insertion_point(field_mutable:tesla.Argument.field)
  return field_;
}
inline ::tesla::StructField* Argument::release_field() {
  // @@protoc_insertion_point(field_release:tesla.Argument.field)
  clear_has_field();
  ::tesla::StructField* temp = field_;
  field_ = NULL;
  return temp;
}
inline void Argument::set_allocated_field(::tesla::StructField* field) {
  delete field_;
  field_ = field;
  if (field) {
    set_has_field();
  } else {
    clear_has_field();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.Argument.field)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tesla

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::tesla::AutomatonDescription_Context> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tesla::AutomatonDescription_Context>() {
  return ::tesla::AutomatonDescription_Context_descriptor();
}
template <> struct is_proto_enum< ::tesla::Expression_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tesla::Expression_Type>() {
  return ::tesla::Expression_Type_descriptor();
}
template <> struct is_proto_enum< ::tesla::BooleanExpr_Operation> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tesla::BooleanExpr_Operation>() {
  return ::tesla::BooleanExpr_Operation_descriptor();
}
template <> struct is_proto_enum< ::tesla::FunctionEvent_Direction> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tesla::FunctionEvent_Direction>() {
  return ::tesla::FunctionEvent_Direction_descriptor();
}
template <> struct is_proto_enum< ::tesla::FunctionEvent_CallContext> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tesla::FunctionEvent_CallContext>() {
  return ::tesla::FunctionEvent_CallContext_descriptor();
}
template <> struct is_proto_enum< ::tesla::FunctionEvent_CallKind> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tesla::FunctionEvent_CallKind>() {
  return ::tesla::FunctionEvent_CallKind_descriptor();
}
template <> struct is_proto_enum< ::tesla::FieldAssignment_AssignType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tesla::FieldAssignment_AssignType>() {
  return ::tesla::FieldAssignment_AssignType_descriptor();
}
template <> struct is_proto_enum< ::tesla::Argument_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tesla::Argument_Type>() {
  return ::tesla::Argument_Type_descriptor();
}
template <> struct is_proto_enum< ::tesla::Argument_MatchType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tesla::Argument_MatchType>() {
  return ::tesla::Argument_MatchType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tesla_2eproto__INCLUDED
