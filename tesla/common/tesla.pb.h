// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tesla.proto

#ifndef PROTOBUF_tesla_2eproto__INCLUDED
#define PROTOBUF_tesla_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace tesla {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_tesla_2eproto();
void protobuf_AssignDesc_tesla_2eproto();
void protobuf_ShutdownFile_tesla_2eproto();

class ManifestFile;
class Usage;
class AutomatonDescription;
class Identifier;
class Location;
class Expression;
class BooleanExpr;
class Sequence;
class AssertionSite;
class FunctionEvent;
class FunctionRef;
class FieldAssignment;
class StructField;
class Argument;

enum AutomatonDescription_Context {
  AutomatonDescription_Context_Global = 1,
  AutomatonDescription_Context_ThreadLocal = 2
};
bool AutomatonDescription_Context_IsValid(int value);
const AutomatonDescription_Context AutomatonDescription_Context_Context_MIN = AutomatonDescription_Context_Global;
const AutomatonDescription_Context AutomatonDescription_Context_Context_MAX = AutomatonDescription_Context_ThreadLocal;
const int AutomatonDescription_Context_Context_ARRAYSIZE = AutomatonDescription_Context_Context_MAX + 1;

const ::google::protobuf::EnumDescriptor* AutomatonDescription_Context_descriptor();
inline const ::std::string& AutomatonDescription_Context_Name(AutomatonDescription_Context value) {
  return ::google::protobuf::internal::NameOfEnum(
    AutomatonDescription_Context_descriptor(), value);
}
inline bool AutomatonDescription_Context_Parse(
    const ::std::string& name, AutomatonDescription_Context* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AutomatonDescription_Context>(
    AutomatonDescription_Context_descriptor(), name, value);
}
enum Expression_Type {
  Expression_Type_BOOLEAN_EXPR = 1,
  Expression_Type_SEQUENCE = 2,
  Expression_Type_NULL_EXPR = 3,
  Expression_Type_ASSERTION_SITE = 4,
  Expression_Type_FUNCTION = 5,
  Expression_Type_FIELD_ASSIGN = 6,
  Expression_Type_SUB_AUTOMATON = 7
};
bool Expression_Type_IsValid(int value);
const Expression_Type Expression_Type_Type_MIN = Expression_Type_BOOLEAN_EXPR;
const Expression_Type Expression_Type_Type_MAX = Expression_Type_SUB_AUTOMATON;
const int Expression_Type_Type_ARRAYSIZE = Expression_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Expression_Type_descriptor();
inline const ::std::string& Expression_Type_Name(Expression_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Expression_Type_descriptor(), value);
}
inline bool Expression_Type_Parse(
    const ::std::string& name, Expression_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Expression_Type>(
    Expression_Type_descriptor(), name, value);
}
enum BooleanExpr_Operation {
  BooleanExpr_Operation_BE_And = 1,
  BooleanExpr_Operation_BE_Or = 2,
  BooleanExpr_Operation_BE_Xor = 3
};
bool BooleanExpr_Operation_IsValid(int value);
const BooleanExpr_Operation BooleanExpr_Operation_Operation_MIN = BooleanExpr_Operation_BE_And;
const BooleanExpr_Operation BooleanExpr_Operation_Operation_MAX = BooleanExpr_Operation_BE_Xor;
const int BooleanExpr_Operation_Operation_ARRAYSIZE = BooleanExpr_Operation_Operation_MAX + 1;

const ::google::protobuf::EnumDescriptor* BooleanExpr_Operation_descriptor();
inline const ::std::string& BooleanExpr_Operation_Name(BooleanExpr_Operation value) {
  return ::google::protobuf::internal::NameOfEnum(
    BooleanExpr_Operation_descriptor(), value);
}
inline bool BooleanExpr_Operation_Parse(
    const ::std::string& name, BooleanExpr_Operation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BooleanExpr_Operation>(
    BooleanExpr_Operation_descriptor(), name, value);
}
enum FunctionEvent_Direction {
  FunctionEvent_Direction_Entry = 1,
  FunctionEvent_Direction_Exit = 2
};
bool FunctionEvent_Direction_IsValid(int value);
const FunctionEvent_Direction FunctionEvent_Direction_Direction_MIN = FunctionEvent_Direction_Entry;
const FunctionEvent_Direction FunctionEvent_Direction_Direction_MAX = FunctionEvent_Direction_Exit;
const int FunctionEvent_Direction_Direction_ARRAYSIZE = FunctionEvent_Direction_Direction_MAX + 1;

const ::google::protobuf::EnumDescriptor* FunctionEvent_Direction_descriptor();
inline const ::std::string& FunctionEvent_Direction_Name(FunctionEvent_Direction value) {
  return ::google::protobuf::internal::NameOfEnum(
    FunctionEvent_Direction_descriptor(), value);
}
inline bool FunctionEvent_Direction_Parse(
    const ::std::string& name, FunctionEvent_Direction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FunctionEvent_Direction>(
    FunctionEvent_Direction_descriptor(), name, value);
}
enum FunctionEvent_CallContext {
  FunctionEvent_CallContext_Caller = 1,
  FunctionEvent_CallContext_Callee = 2
};
bool FunctionEvent_CallContext_IsValid(int value);
const FunctionEvent_CallContext FunctionEvent_CallContext_CallContext_MIN = FunctionEvent_CallContext_Caller;
const FunctionEvent_CallContext FunctionEvent_CallContext_CallContext_MAX = FunctionEvent_CallContext_Callee;
const int FunctionEvent_CallContext_CallContext_ARRAYSIZE = FunctionEvent_CallContext_CallContext_MAX + 1;

const ::google::protobuf::EnumDescriptor* FunctionEvent_CallContext_descriptor();
inline const ::std::string& FunctionEvent_CallContext_Name(FunctionEvent_CallContext value) {
  return ::google::protobuf::internal::NameOfEnum(
    FunctionEvent_CallContext_descriptor(), value);
}
inline bool FunctionEvent_CallContext_Parse(
    const ::std::string& name, FunctionEvent_CallContext* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FunctionEvent_CallContext>(
    FunctionEvent_CallContext_descriptor(), name, value);
}
enum FunctionEvent_CallKind {
  FunctionEvent_CallKind_CCall = 1,
  FunctionEvent_CallKind_ObjCInstanceMessage = 2,
  FunctionEvent_CallKind_ObjCClassMessage = 3,
  FunctionEvent_CallKind_ObjCSuperMessage = 4
};
bool FunctionEvent_CallKind_IsValid(int value);
const FunctionEvent_CallKind FunctionEvent_CallKind_CallKind_MIN = FunctionEvent_CallKind_CCall;
const FunctionEvent_CallKind FunctionEvent_CallKind_CallKind_MAX = FunctionEvent_CallKind_ObjCSuperMessage;
const int FunctionEvent_CallKind_CallKind_ARRAYSIZE = FunctionEvent_CallKind_CallKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* FunctionEvent_CallKind_descriptor();
inline const ::std::string& FunctionEvent_CallKind_Name(FunctionEvent_CallKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    FunctionEvent_CallKind_descriptor(), value);
}
inline bool FunctionEvent_CallKind_Parse(
    const ::std::string& name, FunctionEvent_CallKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FunctionEvent_CallKind>(
    FunctionEvent_CallKind_descriptor(), name, value);
}
enum FieldAssignment_AssignType {
  FieldAssignment_AssignType_SimpleAssign = 1,
  FieldAssignment_AssignType_PlusEqual = 2,
  FieldAssignment_AssignType_MinusEqual = 3
};
bool FieldAssignment_AssignType_IsValid(int value);
const FieldAssignment_AssignType FieldAssignment_AssignType_AssignType_MIN = FieldAssignment_AssignType_SimpleAssign;
const FieldAssignment_AssignType FieldAssignment_AssignType_AssignType_MAX = FieldAssignment_AssignType_MinusEqual;
const int FieldAssignment_AssignType_AssignType_ARRAYSIZE = FieldAssignment_AssignType_AssignType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FieldAssignment_AssignType_descriptor();
inline const ::std::string& FieldAssignment_AssignType_Name(FieldAssignment_AssignType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FieldAssignment_AssignType_descriptor(), value);
}
inline bool FieldAssignment_AssignType_Parse(
    const ::std::string& name, FieldAssignment_AssignType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FieldAssignment_AssignType>(
    FieldAssignment_AssignType_descriptor(), name, value);
}
enum Argument_Type {
  Argument_Type_Constant = 1,
  Argument_Type_Variable = 2,
  Argument_Type_Any = 3,
  Argument_Type_Indirect = 4,
  Argument_Type_Field = 5
};
bool Argument_Type_IsValid(int value);
const Argument_Type Argument_Type_Type_MIN = Argument_Type_Constant;
const Argument_Type Argument_Type_Type_MAX = Argument_Type_Field;
const int Argument_Type_Type_ARRAYSIZE = Argument_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Argument_Type_descriptor();
inline const ::std::string& Argument_Type_Name(Argument_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Argument_Type_descriptor(), value);
}
inline bool Argument_Type_Parse(
    const ::std::string& name, Argument_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Argument_Type>(
    Argument_Type_descriptor(), name, value);
}
enum Argument_MatchType {
  Argument_MatchType_Exact = 1,
  Argument_MatchType_Flags = 2,
  Argument_MatchType_Mask = 3
};
bool Argument_MatchType_IsValid(int value);
const Argument_MatchType Argument_MatchType_MatchType_MIN = Argument_MatchType_Exact;
const Argument_MatchType Argument_MatchType_MatchType_MAX = Argument_MatchType_Mask;
const int Argument_MatchType_MatchType_ARRAYSIZE = Argument_MatchType_MatchType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Argument_MatchType_descriptor();
inline const ::std::string& Argument_MatchType_Name(Argument_MatchType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Argument_MatchType_descriptor(), value);
}
inline bool Argument_MatchType_Parse(
    const ::std::string& name, Argument_MatchType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Argument_MatchType>(
    Argument_MatchType_descriptor(), name, value);
}
// ===================================================================

class ManifestFile : public ::google::protobuf::Message {
 public:
  ManifestFile();
  virtual ~ManifestFile();

  ManifestFile(const ManifestFile& from);

  inline ManifestFile& operator=(const ManifestFile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ManifestFile& default_instance();

  void Swap(ManifestFile* other);

  // implements Message ----------------------------------------------

  ManifestFile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ManifestFile& from);
  void MergeFrom(const ManifestFile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tesla.AutomatonDescription automaton = 1;
  inline int automaton_size() const;
  inline void clear_automaton();
  static const int kAutomatonFieldNumber = 1;
  inline const ::tesla::AutomatonDescription& automaton(int index) const;
  inline ::tesla::AutomatonDescription* mutable_automaton(int index);
  inline ::tesla::AutomatonDescription* add_automaton();
  inline const ::google::protobuf::RepeatedPtrField< ::tesla::AutomatonDescription >&
      automaton() const;
  inline ::google::protobuf::RepeatedPtrField< ::tesla::AutomatonDescription >*
      mutable_automaton();

  // repeated .tesla.Usage root = 2;
  inline int root_size() const;
  inline void clear_root();
  static const int kRootFieldNumber = 2;
  inline const ::tesla::Usage& root(int index) const;
  inline ::tesla::Usage* mutable_root(int index);
  inline ::tesla::Usage* add_root();
  inline const ::google::protobuf::RepeatedPtrField< ::tesla::Usage >&
      root() const;
  inline ::google::protobuf::RepeatedPtrField< ::tesla::Usage >*
      mutable_root();

  // @@protoc_insertion_point(class_scope:tesla.ManifestFile)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::tesla::AutomatonDescription > automaton_;
  ::google::protobuf::RepeatedPtrField< ::tesla::Usage > root_;
  friend void  protobuf_AddDesc_tesla_2eproto();
  friend void protobuf_AssignDesc_tesla_2eproto();
  friend void protobuf_ShutdownFile_tesla_2eproto();

  void InitAsDefaultInstance();
  static ManifestFile* default_instance_;
};
// -------------------------------------------------------------------

class Usage : public ::google::protobuf::Message {
 public:
  Usage();
  virtual ~Usage();

  Usage(const Usage& from);

  inline Usage& operator=(const Usage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Usage& default_instance();

  void Swap(Usage* other);

  // implements Message ----------------------------------------------

  Usage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Usage& from);
  void MergeFrom(const Usage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .tesla.Identifier identifier = 1;
  inline bool has_identifier() const;
  inline void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  inline const ::tesla::Identifier& identifier() const;
  inline ::tesla::Identifier* mutable_identifier();
  inline ::tesla::Identifier* release_identifier();
  inline void set_allocated_identifier(::tesla::Identifier* identifier);

  // optional .tesla.Expression beginning = 2;
  inline bool has_beginning() const;
  inline void clear_beginning();
  static const int kBeginningFieldNumber = 2;
  inline const ::tesla::Expression& beginning() const;
  inline ::tesla::Expression* mutable_beginning();
  inline ::tesla::Expression* release_beginning();
  inline void set_allocated_beginning(::tesla::Expression* beginning);

  // optional .tesla.Expression end = 3;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 3;
  inline const ::tesla::Expression& end() const;
  inline ::tesla::Expression* mutable_end();
  inline ::tesla::Expression* release_end();
  inline void set_allocated_end(::tesla::Expression* end);

  // optional bool deleted = 4 [default = false];
  inline bool has_deleted() const;
  inline void clear_deleted();
  static const int kDeletedFieldNumber = 4;
  inline bool deleted() const;
  inline void set_deleted(bool value);

  // @@protoc_insertion_point(class_scope:tesla.Usage)
 private:
  inline void set_has_identifier();
  inline void clear_has_identifier();
  inline void set_has_beginning();
  inline void clear_has_beginning();
  inline void set_has_end();
  inline void clear_has_end();
  inline void set_has_deleted();
  inline void clear_has_deleted();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::tesla::Identifier* identifier_;
  ::tesla::Expression* beginning_;
  ::tesla::Expression* end_;
  bool deleted_;
  friend void  protobuf_AddDesc_tesla_2eproto();
  friend void protobuf_AssignDesc_tesla_2eproto();
  friend void protobuf_ShutdownFile_tesla_2eproto();

  void InitAsDefaultInstance();
  static Usage* default_instance_;
};
// -------------------------------------------------------------------

class AutomatonDescription : public ::google::protobuf::Message {
 public:
  AutomatonDescription();
  virtual ~AutomatonDescription();

  AutomatonDescription(const AutomatonDescription& from);

  inline AutomatonDescription& operator=(const AutomatonDescription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AutomatonDescription& default_instance();

  void Swap(AutomatonDescription* other);

  // implements Message ----------------------------------------------

  AutomatonDescription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AutomatonDescription& from);
  void MergeFrom(const AutomatonDescription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AutomatonDescription_Context Context;
  static const Context Global = AutomatonDescription_Context_Global;
  static const Context ThreadLocal = AutomatonDescription_Context_ThreadLocal;
  static inline bool Context_IsValid(int value) {
    return AutomatonDescription_Context_IsValid(value);
  }
  static const Context Context_MIN =
    AutomatonDescription_Context_Context_MIN;
  static const Context Context_MAX =
    AutomatonDescription_Context_Context_MAX;
  static const int Context_ARRAYSIZE =
    AutomatonDescription_Context_Context_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Context_descriptor() {
    return AutomatonDescription_Context_descriptor();
  }
  static inline const ::std::string& Context_Name(Context value) {
    return AutomatonDescription_Context_Name(value);
  }
  static inline bool Context_Parse(const ::std::string& name,
      Context* value) {
    return AutomatonDescription_Context_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .tesla.Identifier identifier = 1;
  inline bool has_identifier() const;
  inline void clear_identifier();
  static const int kIdentifierFieldNumber = 1;
  inline const ::tesla::Identifier& identifier() const;
  inline ::tesla::Identifier* mutable_identifier();
  inline ::tesla::Identifier* release_identifier();
  inline void set_allocated_identifier(::tesla::Identifier* identifier);

  // required .tesla.AutomatonDescription.Context context = 2;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 2;
  inline ::tesla::AutomatonDescription_Context context() const;
  inline void set_context(::tesla::AutomatonDescription_Context value);

  // required .tesla.Expression expression = 3;
  inline bool has_expression() const;
  inline void clear_expression();
  static const int kExpressionFieldNumber = 3;
  inline const ::tesla::Expression& expression() const;
  inline ::tesla::Expression* mutable_expression();
  inline ::tesla::Expression* release_expression();
  inline void set_allocated_expression(::tesla::Expression* expression);

  // repeated .tesla.Argument argument = 5;
  inline int argument_size() const;
  inline void clear_argument();
  static const int kArgumentFieldNumber = 5;
  inline const ::tesla::Argument& argument(int index) const;
  inline ::tesla::Argument* mutable_argument(int index);
  inline ::tesla::Argument* add_argument();
  inline const ::google::protobuf::RepeatedPtrField< ::tesla::Argument >&
      argument() const;
  inline ::google::protobuf::RepeatedPtrField< ::tesla::Argument >*
      mutable_argument();

  // optional string source = 6;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 6;
  inline const ::std::string& source() const;
  inline void set_source(const ::std::string& value);
  inline void set_source(const char* value);
  inline void set_source(const char* value, size_t size);
  inline ::std::string* mutable_source();
  inline ::std::string* release_source();
  inline void set_allocated_source(::std::string* source);

  // @@protoc_insertion_point(class_scope:tesla.AutomatonDescription)
 private:
  inline void set_has_identifier();
  inline void clear_has_identifier();
  inline void set_has_context();
  inline void clear_has_context();
  inline void set_has_expression();
  inline void clear_has_expression();
  inline void set_has_source();
  inline void clear_has_source();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::tesla::Identifier* identifier_;
  ::tesla::Expression* expression_;
  ::google::protobuf::RepeatedPtrField< ::tesla::Argument > argument_;
  ::std::string* source_;
  int context_;
  friend void  protobuf_AddDesc_tesla_2eproto();
  friend void protobuf_AssignDesc_tesla_2eproto();
  friend void protobuf_ShutdownFile_tesla_2eproto();

  void InitAsDefaultInstance();
  static AutomatonDescription* default_instance_;
};
// -------------------------------------------------------------------

class Identifier : public ::google::protobuf::Message {
 public:
  Identifier();
  virtual ~Identifier();

  Identifier(const Identifier& from);

  inline Identifier& operator=(const Identifier& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Identifier& default_instance();

  void Swap(Identifier* other);

  // implements Message ----------------------------------------------

  Identifier* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Identifier& from);
  void MergeFrom(const Identifier& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .tesla.Location location = 2;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 2;
  inline const ::tesla::Location& location() const;
  inline ::tesla::Location* mutable_location();
  inline ::tesla::Location* release_location();
  inline void set_allocated_location(::tesla::Location* location);

  // @@protoc_insertion_point(class_scope:tesla.Identifier)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_location();
  inline void clear_has_location();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::tesla::Location* location_;
  friend void  protobuf_AddDesc_tesla_2eproto();
  friend void protobuf_AssignDesc_tesla_2eproto();
  friend void protobuf_ShutdownFile_tesla_2eproto();

  void InitAsDefaultInstance();
  static Identifier* default_instance_;
};
// -------------------------------------------------------------------

class Location : public ::google::protobuf::Message {
 public:
  Location();
  virtual ~Location();

  Location(const Location& from);

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Location& default_instance();

  void Swap(Location* other);

  // implements Message ----------------------------------------------

  Location* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Location& from);
  void MergeFrom(const Location& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string filename = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 1;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // required int32 line = 2;
  inline bool has_line() const;
  inline void clear_line();
  static const int kLineFieldNumber = 2;
  inline ::google::protobuf::int32 line() const;
  inline void set_line(::google::protobuf::int32 value);

  // required int32 counter = 3;
  inline bool has_counter() const;
  inline void clear_counter();
  static const int kCounterFieldNumber = 3;
  inline ::google::protobuf::int32 counter() const;
  inline void set_counter(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tesla.Location)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_line();
  inline void clear_has_line();
  inline void set_has_counter();
  inline void clear_has_counter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* filename_;
  ::google::protobuf::int32 line_;
  ::google::protobuf::int32 counter_;
  friend void  protobuf_AddDesc_tesla_2eproto();
  friend void protobuf_AssignDesc_tesla_2eproto();
  friend void protobuf_ShutdownFile_tesla_2eproto();

  void InitAsDefaultInstance();
  static Location* default_instance_;
};
// -------------------------------------------------------------------

class Expression : public ::google::protobuf::Message {
 public:
  Expression();
  virtual ~Expression();

  Expression(const Expression& from);

  inline Expression& operator=(const Expression& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression& default_instance();

  void Swap(Expression* other);

  // implements Message ----------------------------------------------

  Expression* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Expression& from);
  void MergeFrom(const Expression& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Expression_Type Type;
  static const Type BOOLEAN_EXPR = Expression_Type_BOOLEAN_EXPR;
  static const Type SEQUENCE = Expression_Type_SEQUENCE;
  static const Type NULL_EXPR = Expression_Type_NULL_EXPR;
  static const Type ASSERTION_SITE = Expression_Type_ASSERTION_SITE;
  static const Type FUNCTION = Expression_Type_FUNCTION;
  static const Type FIELD_ASSIGN = Expression_Type_FIELD_ASSIGN;
  static const Type SUB_AUTOMATON = Expression_Type_SUB_AUTOMATON;
  static inline bool Type_IsValid(int value) {
    return Expression_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Expression_Type_Type_MIN;
  static const Type Type_MAX =
    Expression_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Expression_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Expression_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Expression_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Expression_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .tesla.Expression.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::tesla::Expression_Type type() const;
  inline void set_type(::tesla::Expression_Type value);

  // optional .tesla.BooleanExpr booleanExpr = 2;
  inline bool has_booleanexpr() const;
  inline void clear_booleanexpr();
  static const int kBooleanExprFieldNumber = 2;
  inline const ::tesla::BooleanExpr& booleanexpr() const;
  inline ::tesla::BooleanExpr* mutable_booleanexpr();
  inline ::tesla::BooleanExpr* release_booleanexpr();
  inline void set_allocated_booleanexpr(::tesla::BooleanExpr* booleanexpr);

  // optional .tesla.Sequence sequence = 3;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 3;
  inline const ::tesla::Sequence& sequence() const;
  inline ::tesla::Sequence* mutable_sequence();
  inline ::tesla::Sequence* release_sequence();
  inline void set_allocated_sequence(::tesla::Sequence* sequence);

  // optional .tesla.AssertionSite assertSite = 4;
  inline bool has_assertsite() const;
  inline void clear_assertsite();
  static const int kAssertSiteFieldNumber = 4;
  inline const ::tesla::AssertionSite& assertsite() const;
  inline ::tesla::AssertionSite* mutable_assertsite();
  inline ::tesla::AssertionSite* release_assertsite();
  inline void set_allocated_assertsite(::tesla::AssertionSite* assertsite);

  // optional .tesla.FunctionEvent function = 5;
  inline bool has_function() const;
  inline void clear_function();
  static const int kFunctionFieldNumber = 5;
  inline const ::tesla::FunctionEvent& function() const;
  inline ::tesla::FunctionEvent* mutable_function();
  inline ::tesla::FunctionEvent* release_function();
  inline void set_allocated_function(::tesla::FunctionEvent* function);

  // optional .tesla.FieldAssignment fieldAssign = 6;
  inline bool has_fieldassign() const;
  inline void clear_fieldassign();
  static const int kFieldAssignFieldNumber = 6;
  inline const ::tesla::FieldAssignment& fieldassign() const;
  inline ::tesla::FieldAssignment* mutable_fieldassign();
  inline ::tesla::FieldAssignment* release_fieldassign();
  inline void set_allocated_fieldassign(::tesla::FieldAssignment* fieldassign);

  // optional .tesla.Identifier subAutomaton = 7;
  inline bool has_subautomaton() const;
  inline void clear_subautomaton();
  static const int kSubAutomatonFieldNumber = 7;
  inline const ::tesla::Identifier& subautomaton() const;
  inline ::tesla::Identifier* mutable_subautomaton();
  inline ::tesla::Identifier* release_subautomaton();
  inline void set_allocated_subautomaton(::tesla::Identifier* subautomaton);

  // @@protoc_insertion_point(class_scope:tesla.Expression)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_booleanexpr();
  inline void clear_has_booleanexpr();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_assertsite();
  inline void clear_has_assertsite();
  inline void set_has_function();
  inline void clear_has_function();
  inline void set_has_fieldassign();
  inline void clear_has_fieldassign();
  inline void set_has_subautomaton();
  inline void clear_has_subautomaton();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::tesla::BooleanExpr* booleanexpr_;
  ::tesla::Sequence* sequence_;
  ::tesla::AssertionSite* assertsite_;
  ::tesla::FunctionEvent* function_;
  ::tesla::FieldAssignment* fieldassign_;
  ::tesla::Identifier* subautomaton_;
  int type_;
  friend void  protobuf_AddDesc_tesla_2eproto();
  friend void protobuf_AssignDesc_tesla_2eproto();
  friend void protobuf_ShutdownFile_tesla_2eproto();

  void InitAsDefaultInstance();
  static Expression* default_instance_;
};
// -------------------------------------------------------------------

class BooleanExpr : public ::google::protobuf::Message {
 public:
  BooleanExpr();
  virtual ~BooleanExpr();

  BooleanExpr(const BooleanExpr& from);

  inline BooleanExpr& operator=(const BooleanExpr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BooleanExpr& default_instance();

  void Swap(BooleanExpr* other);

  // implements Message ----------------------------------------------

  BooleanExpr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BooleanExpr& from);
  void MergeFrom(const BooleanExpr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef BooleanExpr_Operation Operation;
  static const Operation BE_And = BooleanExpr_Operation_BE_And;
  static const Operation BE_Or = BooleanExpr_Operation_BE_Or;
  static const Operation BE_Xor = BooleanExpr_Operation_BE_Xor;
  static inline bool Operation_IsValid(int value) {
    return BooleanExpr_Operation_IsValid(value);
  }
  static const Operation Operation_MIN =
    BooleanExpr_Operation_Operation_MIN;
  static const Operation Operation_MAX =
    BooleanExpr_Operation_Operation_MAX;
  static const int Operation_ARRAYSIZE =
    BooleanExpr_Operation_Operation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Operation_descriptor() {
    return BooleanExpr_Operation_descriptor();
  }
  static inline const ::std::string& Operation_Name(Operation value) {
    return BooleanExpr_Operation_Name(value);
  }
  static inline bool Operation_Parse(const ::std::string& name,
      Operation* value) {
    return BooleanExpr_Operation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .tesla.BooleanExpr.Operation operation = 1;
  inline bool has_operation() const;
  inline void clear_operation();
  static const int kOperationFieldNumber = 1;
  inline ::tesla::BooleanExpr_Operation operation() const;
  inline void set_operation(::tesla::BooleanExpr_Operation value);

  // repeated .tesla.Expression expression = 2;
  inline int expression_size() const;
  inline void clear_expression();
  static const int kExpressionFieldNumber = 2;
  inline const ::tesla::Expression& expression(int index) const;
  inline ::tesla::Expression* mutable_expression(int index);
  inline ::tesla::Expression* add_expression();
  inline const ::google::protobuf::RepeatedPtrField< ::tesla::Expression >&
      expression() const;
  inline ::google::protobuf::RepeatedPtrField< ::tesla::Expression >*
      mutable_expression();

  // @@protoc_insertion_point(class_scope:tesla.BooleanExpr)
 private:
  inline void set_has_operation();
  inline void clear_has_operation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::tesla::Expression > expression_;
  int operation_;
  friend void  protobuf_AddDesc_tesla_2eproto();
  friend void protobuf_AssignDesc_tesla_2eproto();
  friend void protobuf_ShutdownFile_tesla_2eproto();

  void InitAsDefaultInstance();
  static BooleanExpr* default_instance_;
};
// -------------------------------------------------------------------

class Sequence : public ::google::protobuf::Message {
 public:
  Sequence();
  virtual ~Sequence();

  Sequence(const Sequence& from);

  inline Sequence& operator=(const Sequence& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sequence& default_instance();

  void Swap(Sequence* other);

  // implements Message ----------------------------------------------

  Sequence* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sequence& from);
  void MergeFrom(const Sequence& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tesla.Expression expression = 1;
  inline int expression_size() const;
  inline void clear_expression();
  static const int kExpressionFieldNumber = 1;
  inline const ::tesla::Expression& expression(int index) const;
  inline ::tesla::Expression* mutable_expression(int index);
  inline ::tesla::Expression* add_expression();
  inline const ::google::protobuf::RepeatedPtrField< ::tesla::Expression >&
      expression() const;
  inline ::google::protobuf::RepeatedPtrField< ::tesla::Expression >*
      mutable_expression();

  // optional int32 minReps = 2 [default = 1];
  inline bool has_minreps() const;
  inline void clear_minreps();
  static const int kMinRepsFieldNumber = 2;
  inline ::google::protobuf::int32 minreps() const;
  inline void set_minreps(::google::protobuf::int32 value);

  // optional int32 maxReps = 3 [default = 1];
  inline bool has_maxreps() const;
  inline void clear_maxreps();
  static const int kMaxRepsFieldNumber = 3;
  inline ::google::protobuf::int32 maxreps() const;
  inline void set_maxreps(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tesla.Sequence)
 private:
  inline void set_has_minreps();
  inline void clear_has_minreps();
  inline void set_has_maxreps();
  inline void clear_has_maxreps();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::tesla::Expression > expression_;
  ::google::protobuf::int32 minreps_;
  ::google::protobuf::int32 maxreps_;
  friend void  protobuf_AddDesc_tesla_2eproto();
  friend void protobuf_AssignDesc_tesla_2eproto();
  friend void protobuf_ShutdownFile_tesla_2eproto();

  void InitAsDefaultInstance();
  static Sequence* default_instance_;
};
// -------------------------------------------------------------------

class AssertionSite : public ::google::protobuf::Message {
 public:
  AssertionSite();
  virtual ~AssertionSite();

  AssertionSite(const AssertionSite& from);

  inline AssertionSite& operator=(const AssertionSite& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AssertionSite& default_instance();

  void Swap(AssertionSite* other);

  // implements Message ----------------------------------------------

  AssertionSite* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AssertionSite& from);
  void MergeFrom(const AssertionSite& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .tesla.Location location = 1;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 1;
  inline const ::tesla::Location& location() const;
  inline ::tesla::Location* mutable_location();
  inline ::tesla::Location* release_location();
  inline void set_allocated_location(::tesla::Location* location);

  // @@protoc_insertion_point(class_scope:tesla.AssertionSite)
 private:
  inline void set_has_location();
  inline void clear_has_location();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::tesla::Location* location_;
  friend void  protobuf_AddDesc_tesla_2eproto();
  friend void protobuf_AssignDesc_tesla_2eproto();
  friend void protobuf_ShutdownFile_tesla_2eproto();

  void InitAsDefaultInstance();
  static AssertionSite* default_instance_;
};
// -------------------------------------------------------------------

class FunctionEvent : public ::google::protobuf::Message {
 public:
  FunctionEvent();
  virtual ~FunctionEvent();

  FunctionEvent(const FunctionEvent& from);

  inline FunctionEvent& operator=(const FunctionEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FunctionEvent& default_instance();

  void Swap(FunctionEvent* other);

  // implements Message ----------------------------------------------

  FunctionEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FunctionEvent& from);
  void MergeFrom(const FunctionEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef FunctionEvent_Direction Direction;
  static const Direction Entry = FunctionEvent_Direction_Entry;
  static const Direction Exit = FunctionEvent_Direction_Exit;
  static inline bool Direction_IsValid(int value) {
    return FunctionEvent_Direction_IsValid(value);
  }
  static const Direction Direction_MIN =
    FunctionEvent_Direction_Direction_MIN;
  static const Direction Direction_MAX =
    FunctionEvent_Direction_Direction_MAX;
  static const int Direction_ARRAYSIZE =
    FunctionEvent_Direction_Direction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Direction_descriptor() {
    return FunctionEvent_Direction_descriptor();
  }
  static inline const ::std::string& Direction_Name(Direction value) {
    return FunctionEvent_Direction_Name(value);
  }
  static inline bool Direction_Parse(const ::std::string& name,
      Direction* value) {
    return FunctionEvent_Direction_Parse(name, value);
  }

  typedef FunctionEvent_CallContext CallContext;
  static const CallContext Caller = FunctionEvent_CallContext_Caller;
  static const CallContext Callee = FunctionEvent_CallContext_Callee;
  static inline bool CallContext_IsValid(int value) {
    return FunctionEvent_CallContext_IsValid(value);
  }
  static const CallContext CallContext_MIN =
    FunctionEvent_CallContext_CallContext_MIN;
  static const CallContext CallContext_MAX =
    FunctionEvent_CallContext_CallContext_MAX;
  static const int CallContext_ARRAYSIZE =
    FunctionEvent_CallContext_CallContext_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CallContext_descriptor() {
    return FunctionEvent_CallContext_descriptor();
  }
  static inline const ::std::string& CallContext_Name(CallContext value) {
    return FunctionEvent_CallContext_Name(value);
  }
  static inline bool CallContext_Parse(const ::std::string& name,
      CallContext* value) {
    return FunctionEvent_CallContext_Parse(name, value);
  }

  typedef FunctionEvent_CallKind CallKind;
  static const CallKind CCall = FunctionEvent_CallKind_CCall;
  static const CallKind ObjCInstanceMessage = FunctionEvent_CallKind_ObjCInstanceMessage;
  static const CallKind ObjCClassMessage = FunctionEvent_CallKind_ObjCClassMessage;
  static const CallKind ObjCSuperMessage = FunctionEvent_CallKind_ObjCSuperMessage;
  static inline bool CallKind_IsValid(int value) {
    return FunctionEvent_CallKind_IsValid(value);
  }
  static const CallKind CallKind_MIN =
    FunctionEvent_CallKind_CallKind_MIN;
  static const CallKind CallKind_MAX =
    FunctionEvent_CallKind_CallKind_MAX;
  static const int CallKind_ARRAYSIZE =
    FunctionEvent_CallKind_CallKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CallKind_descriptor() {
    return FunctionEvent_CallKind_descriptor();
  }
  static inline const ::std::string& CallKind_Name(CallKind value) {
    return FunctionEvent_CallKind_Name(value);
  }
  static inline bool CallKind_Parse(const ::std::string& name,
      CallKind* value) {
    return FunctionEvent_CallKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .tesla.FunctionRef function = 1;
  inline bool has_function() const;
  inline void clear_function();
  static const int kFunctionFieldNumber = 1;
  inline const ::tesla::FunctionRef& function() const;
  inline ::tesla::FunctionRef* mutable_function();
  inline ::tesla::FunctionRef* release_function();
  inline void set_allocated_function(::tesla::FunctionRef* function);

  // optional .tesla.FunctionEvent.Direction direction = 2;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 2;
  inline ::tesla::FunctionEvent_Direction direction() const;
  inline void set_direction(::tesla::FunctionEvent_Direction value);

  // optional .tesla.FunctionEvent.CallContext context = 3;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 3;
  inline ::tesla::FunctionEvent_CallContext context() const;
  inline void set_context(::tesla::FunctionEvent_CallContext value);

  // repeated .tesla.Argument argument = 4;
  inline int argument_size() const;
  inline void clear_argument();
  static const int kArgumentFieldNumber = 4;
  inline const ::tesla::Argument& argument(int index) const;
  inline ::tesla::Argument* mutable_argument(int index);
  inline ::tesla::Argument* add_argument();
  inline const ::google::protobuf::RepeatedPtrField< ::tesla::Argument >&
      argument() const;
  inline ::google::protobuf::RepeatedPtrField< ::tesla::Argument >*
      mutable_argument();

  // optional .tesla.Argument expectedReturnValue = 5;
  inline bool has_expectedreturnvalue() const;
  inline void clear_expectedreturnvalue();
  static const int kExpectedReturnValueFieldNumber = 5;
  inline const ::tesla::Argument& expectedreturnvalue() const;
  inline ::tesla::Argument* mutable_expectedreturnvalue();
  inline ::tesla::Argument* release_expectedreturnvalue();
  inline void set_allocated_expectedreturnvalue(::tesla::Argument* expectedreturnvalue);

  // optional bool strict = 6 [default = true];
  inline bool has_strict() const;
  inline void clear_strict();
  static const int kStrictFieldNumber = 6;
  inline bool strict() const;
  inline void set_strict(bool value);

  // optional .tesla.FunctionEvent.CallKind kind = 7 [default = CCall];
  inline bool has_kind() const;
  inline void clear_kind();
  static const int kKindFieldNumber = 7;
  inline ::tesla::FunctionEvent_CallKind kind() const;
  inline void set_kind(::tesla::FunctionEvent_CallKind value);

  // optional .tesla.Argument receiver = 8;
  inline bool has_receiver() const;
  inline void clear_receiver();
  static const int kReceiverFieldNumber = 8;
  inline const ::tesla::Argument& receiver() const;
  inline ::tesla::Argument* mutable_receiver();
  inline ::tesla::Argument* release_receiver();
  inline void set_allocated_receiver(::tesla::Argument* receiver);

  // @@protoc_insertion_point(class_scope:tesla.FunctionEvent)
 private:
  inline void set_has_function();
  inline void clear_has_function();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_context();
  inline void clear_has_context();
  inline void set_has_expectedreturnvalue();
  inline void clear_has_expectedreturnvalue();
  inline void set_has_strict();
  inline void clear_has_strict();
  inline void set_has_kind();
  inline void clear_has_kind();
  inline void set_has_receiver();
  inline void clear_has_receiver();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::tesla::FunctionRef* function_;
  int direction_;
  int context_;
  ::google::protobuf::RepeatedPtrField< ::tesla::Argument > argument_;
  ::tesla::Argument* expectedreturnvalue_;
  bool strict_;
  int kind_;
  ::tesla::Argument* receiver_;
  friend void  protobuf_AddDesc_tesla_2eproto();
  friend void protobuf_AssignDesc_tesla_2eproto();
  friend void protobuf_ShutdownFile_tesla_2eproto();

  void InitAsDefaultInstance();
  static FunctionEvent* default_instance_;
};
// -------------------------------------------------------------------

class FunctionRef : public ::google::protobuf::Message {
 public:
  FunctionRef();
  virtual ~FunctionRef();

  FunctionRef(const FunctionRef& from);

  inline FunctionRef& operator=(const FunctionRef& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FunctionRef& default_instance();

  void Swap(FunctionRef* other);

  // implements Message ----------------------------------------------

  FunctionRef* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FunctionRef& from);
  void MergeFrom(const FunctionRef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:tesla.FunctionRef)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  friend void  protobuf_AddDesc_tesla_2eproto();
  friend void protobuf_AssignDesc_tesla_2eproto();
  friend void protobuf_ShutdownFile_tesla_2eproto();

  void InitAsDefaultInstance();
  static FunctionRef* default_instance_;
};
// -------------------------------------------------------------------

class FieldAssignment : public ::google::protobuf::Message {
 public:
  FieldAssignment();
  virtual ~FieldAssignment();

  FieldAssignment(const FieldAssignment& from);

  inline FieldAssignment& operator=(const FieldAssignment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FieldAssignment& default_instance();

  void Swap(FieldAssignment* other);

  // implements Message ----------------------------------------------

  FieldAssignment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FieldAssignment& from);
  void MergeFrom(const FieldAssignment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef FieldAssignment_AssignType AssignType;
  static const AssignType SimpleAssign = FieldAssignment_AssignType_SimpleAssign;
  static const AssignType PlusEqual = FieldAssignment_AssignType_PlusEqual;
  static const AssignType MinusEqual = FieldAssignment_AssignType_MinusEqual;
  static inline bool AssignType_IsValid(int value) {
    return FieldAssignment_AssignType_IsValid(value);
  }
  static const AssignType AssignType_MIN =
    FieldAssignment_AssignType_AssignType_MIN;
  static const AssignType AssignType_MAX =
    FieldAssignment_AssignType_AssignType_MAX;
  static const int AssignType_ARRAYSIZE =
    FieldAssignment_AssignType_AssignType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AssignType_descriptor() {
    return FieldAssignment_AssignType_descriptor();
  }
  static inline const ::std::string& AssignType_Name(AssignType value) {
    return FieldAssignment_AssignType_Name(value);
  }
  static inline bool AssignType_Parse(const ::std::string& name,
      AssignType* value) {
    return FieldAssignment_AssignType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .tesla.StructField field = 8;
  inline bool has_field() const;
  inline void clear_field();
  static const int kFieldFieldNumber = 8;
  inline const ::tesla::StructField& field() const;
  inline ::tesla::StructField* mutable_field();
  inline ::tesla::StructField* release_field();
  inline void set_allocated_field(::tesla::StructField* field);

  // required .tesla.FieldAssignment.AssignType operation = 4;
  inline bool has_operation() const;
  inline void clear_operation();
  static const int kOperationFieldNumber = 4;
  inline ::tesla::FieldAssignment_AssignType operation() const;
  inline void set_operation(::tesla::FieldAssignment_AssignType value);

  // required .tesla.Argument value = 5;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 5;
  inline const ::tesla::Argument& value() const;
  inline ::tesla::Argument* mutable_value();
  inline ::tesla::Argument* release_value();
  inline void set_allocated_value(::tesla::Argument* value);

  // optional bool strict = 7 [default = true];
  inline bool has_strict() const;
  inline void clear_strict();
  static const int kStrictFieldNumber = 7;
  inline bool strict() const;
  inline void set_strict(bool value);

  // @@protoc_insertion_point(class_scope:tesla.FieldAssignment)
 private:
  inline void set_has_field();
  inline void clear_has_field();
  inline void set_has_operation();
  inline void clear_has_operation();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_strict();
  inline void clear_has_strict();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::tesla::StructField* field_;
  ::tesla::Argument* value_;
  int operation_;
  bool strict_;
  friend void  protobuf_AddDesc_tesla_2eproto();
  friend void protobuf_AssignDesc_tesla_2eproto();
  friend void protobuf_ShutdownFile_tesla_2eproto();

  void InitAsDefaultInstance();
  static FieldAssignment* default_instance_;
};
// -------------------------------------------------------------------

class StructField : public ::google::protobuf::Message {
 public:
  StructField();
  virtual ~StructField();

  StructField(const StructField& from);

  inline StructField& operator=(const StructField& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StructField& default_instance();

  void Swap(StructField* other);

  // implements Message ----------------------------------------------

  StructField* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StructField& from);
  void MergeFrom(const StructField& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // required .tesla.Argument base = 2;
  inline bool has_base() const;
  inline void clear_base();
  static const int kBaseFieldNumber = 2;
  inline const ::tesla::Argument& base() const;
  inline ::tesla::Argument* mutable_base();
  inline ::tesla::Argument* release_base();
  inline void set_allocated_base(::tesla::Argument* base);

  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 index = 4;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 4;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tesla.StructField)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_base();
  inline void clear_has_base();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* type_;
  ::tesla::Argument* base_;
  ::std::string* name_;
  ::google::protobuf::int32 index_;
  friend void  protobuf_AddDesc_tesla_2eproto();
  friend void protobuf_AssignDesc_tesla_2eproto();
  friend void protobuf_ShutdownFile_tesla_2eproto();

  void InitAsDefaultInstance();
  static StructField* default_instance_;
};
// -------------------------------------------------------------------

class Argument : public ::google::protobuf::Message {
 public:
  Argument();
  virtual ~Argument();

  Argument(const Argument& from);

  inline Argument& operator=(const Argument& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Argument& default_instance();

  void Swap(Argument* other);

  // implements Message ----------------------------------------------

  Argument* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Argument& from);
  void MergeFrom(const Argument& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Argument_Type Type;
  static const Type Constant = Argument_Type_Constant;
  static const Type Variable = Argument_Type_Variable;
  static const Type Any = Argument_Type_Any;
  static const Type Indirect = Argument_Type_Indirect;
  static const Type Field = Argument_Type_Field;
  static inline bool Type_IsValid(int value) {
    return Argument_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Argument_Type_Type_MIN;
  static const Type Type_MAX =
    Argument_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Argument_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Argument_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Argument_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Argument_Type_Parse(name, value);
  }

  typedef Argument_MatchType MatchType;
  static const MatchType Exact = Argument_MatchType_Exact;
  static const MatchType Flags = Argument_MatchType_Flags;
  static const MatchType Mask = Argument_MatchType_Mask;
  static inline bool MatchType_IsValid(int value) {
    return Argument_MatchType_IsValid(value);
  }
  static const MatchType MatchType_MIN =
    Argument_MatchType_MatchType_MIN;
  static const MatchType MatchType_MAX =
    Argument_MatchType_MatchType_MAX;
  static const int MatchType_ARRAYSIZE =
    Argument_MatchType_MatchType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MatchType_descriptor() {
    return Argument_MatchType_descriptor();
  }
  static inline const ::std::string& MatchType_Name(MatchType value) {
    return Argument_MatchType_Name(value);
  }
  static inline bool MatchType_Parse(const ::std::string& name,
      MatchType* value) {
    return Argument_MatchType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .tesla.Argument.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::tesla::Argument_Type type() const;
  inline void set_type(::tesla::Argument_Type value);

  // optional int32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bool free = 9 [default = false];
  inline bool has_free() const;
  inline void clear_free();
  static const int kFreeFieldNumber = 9;
  inline bool free() const;
  inline void set_free(bool value);

  // optional int64 value = 5;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 5;
  inline ::google::protobuf::int64 value() const;
  inline void set_value(::google::protobuf::int64 value);

  // optional .tesla.Argument.MatchType constantMatch = 6 [default = Exact];
  inline bool has_constantmatch() const;
  inline void clear_constantmatch();
  static const int kConstantMatchFieldNumber = 6;
  inline ::tesla::Argument_MatchType constantmatch() const;
  inline void set_constantmatch(::tesla::Argument_MatchType value);

  // optional .tesla.Argument indirection = 7;
  inline bool has_indirection() const;
  inline void clear_indirection();
  static const int kIndirectionFieldNumber = 7;
  inline const ::tesla::Argument& indirection() const;
  inline ::tesla::Argument* mutable_indirection();
  inline ::tesla::Argument* release_indirection();
  inline void set_allocated_indirection(::tesla::Argument* indirection);

  // optional .tesla.StructField field = 8;
  inline bool has_field() const;
  inline void clear_field();
  static const int kFieldFieldNumber = 8;
  inline const ::tesla::StructField& field() const;
  inline ::tesla::StructField* mutable_field();
  inline ::tesla::StructField* release_field();
  inline void set_allocated_field(::tesla::StructField* field);

  // @@protoc_insertion_point(class_scope:tesla.Argument)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_free();
  inline void clear_has_free();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_constantmatch();
  inline void clear_has_constantmatch();
  inline void set_has_indirection();
  inline void clear_has_indirection();
  inline void set_has_field();
  inline void clear_has_field();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  ::google::protobuf::int32 index_;
  ::std::string* name_;
  ::google::protobuf::int64 value_;
  bool free_;
  int constantmatch_;
  ::tesla::Argument* indirection_;
  ::tesla::StructField* field_;
  friend void  protobuf_AddDesc_tesla_2eproto();
  friend void protobuf_AssignDesc_tesla_2eproto();
  friend void protobuf_ShutdownFile_tesla_2eproto();

  void InitAsDefaultInstance();
  static Argument* default_instance_;
};
// ===================================================================


// ===================================================================

// ManifestFile

// repeated .tesla.AutomatonDescription automaton = 1;
inline int ManifestFile::automaton_size() const {
  return automaton_.size();
}
inline void ManifestFile::clear_automaton() {
  automaton_.Clear();
}
inline const ::tesla::AutomatonDescription& ManifestFile::automaton(int index) const {
  // @@protoc_insertion_point(field_get:tesla.ManifestFile.automaton)
  return automaton_.Get(index);
}
inline ::tesla::AutomatonDescription* ManifestFile::mutable_automaton(int index) {
  // @@protoc_insertion_point(field_mutable:tesla.ManifestFile.automaton)
  return automaton_.Mutable(index);
}
inline ::tesla::AutomatonDescription* ManifestFile::add_automaton() {
  // @@protoc_insertion_point(field_add:tesla.ManifestFile.automaton)
  return automaton_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tesla::AutomatonDescription >&
ManifestFile::automaton() const {
  // @@protoc_insertion_point(field_list:tesla.ManifestFile.automaton)
  return automaton_;
}
inline ::google::protobuf::RepeatedPtrField< ::tesla::AutomatonDescription >*
ManifestFile::mutable_automaton() {
  // @@protoc_insertion_point(field_mutable_list:tesla.ManifestFile.automaton)
  return &automaton_;
}

// repeated .tesla.Usage root = 2;
inline int ManifestFile::root_size() const {
  return root_.size();
}
inline void ManifestFile::clear_root() {
  root_.Clear();
}
inline const ::tesla::Usage& ManifestFile::root(int index) const {
  // @@protoc_insertion_point(field_get:tesla.ManifestFile.root)
  return root_.Get(index);
}
inline ::tesla::Usage* ManifestFile::mutable_root(int index) {
  // @@protoc_insertion_point(field_mutable:tesla.ManifestFile.root)
  return root_.Mutable(index);
}
inline ::tesla::Usage* ManifestFile::add_root() {
  // @@protoc_insertion_point(field_add:tesla.ManifestFile.root)
  return root_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tesla::Usage >&
ManifestFile::root() const {
  // @@protoc_insertion_point(field_list:tesla.ManifestFile.root)
  return root_;
}
inline ::google::protobuf::RepeatedPtrField< ::tesla::Usage >*
ManifestFile::mutable_root() {
  // @@protoc_insertion_point(field_mutable_list:tesla.ManifestFile.root)
  return &root_;
}

// -------------------------------------------------------------------

// Usage

// required .tesla.Identifier identifier = 1;
inline bool Usage::has_identifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Usage::set_has_identifier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Usage::clear_has_identifier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Usage::clear_identifier() {
  if (identifier_ != NULL) identifier_->::tesla::Identifier::Clear();
  clear_has_identifier();
}
inline const ::tesla::Identifier& Usage::identifier() const {
  // @@protoc_insertion_point(field_get:tesla.Usage.identifier)
  return identifier_ != NULL ? *identifier_ : *default_instance_->identifier_;
}
inline ::tesla::Identifier* Usage::mutable_identifier() {
  set_has_identifier();
  if (identifier_ == NULL) identifier_ = new ::tesla::Identifier;
  // @@protoc_insertion_point(field_mutable:tesla.Usage.identifier)
  return identifier_;
}
inline ::tesla::Identifier* Usage::release_identifier() {
  clear_has_identifier();
  ::tesla::Identifier* temp = identifier_;
  identifier_ = NULL;
  return temp;
}
inline void Usage::set_allocated_identifier(::tesla::Identifier* identifier) {
  delete identifier_;
  identifier_ = identifier;
  if (identifier) {
    set_has_identifier();
  } else {
    clear_has_identifier();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.Usage.identifier)
}

// optional .tesla.Expression beginning = 2;
inline bool Usage::has_beginning() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Usage::set_has_beginning() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Usage::clear_has_beginning() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Usage::clear_beginning() {
  if (beginning_ != NULL) beginning_->::tesla::Expression::Clear();
  clear_has_beginning();
}
inline const ::tesla::Expression& Usage::beginning() const {
  // @@protoc_insertion_point(field_get:tesla.Usage.beginning)
  return beginning_ != NULL ? *beginning_ : *default_instance_->beginning_;
}
inline ::tesla::Expression* Usage::mutable_beginning() {
  set_has_beginning();
  if (beginning_ == NULL) beginning_ = new ::tesla::Expression;
  // @@protoc_insertion_point(field_mutable:tesla.Usage.beginning)
  return beginning_;
}
inline ::tesla::Expression* Usage::release_beginning() {
  clear_has_beginning();
  ::tesla::Expression* temp = beginning_;
  beginning_ = NULL;
  return temp;
}
inline void Usage::set_allocated_beginning(::tesla::Expression* beginning) {
  delete beginning_;
  beginning_ = beginning;
  if (beginning) {
    set_has_beginning();
  } else {
    clear_has_beginning();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.Usage.beginning)
}

// optional .tesla.Expression end = 3;
inline bool Usage::has_end() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Usage::set_has_end() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Usage::clear_has_end() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Usage::clear_end() {
  if (end_ != NULL) end_->::tesla::Expression::Clear();
  clear_has_end();
}
inline const ::tesla::Expression& Usage::end() const {
  // @@protoc_insertion_point(field_get:tesla.Usage.end)
  return end_ != NULL ? *end_ : *default_instance_->end_;
}
inline ::tesla::Expression* Usage::mutable_end() {
  set_has_end();
  if (end_ == NULL) end_ = new ::tesla::Expression;
  // @@protoc_insertion_point(field_mutable:tesla.Usage.end)
  return end_;
}
inline ::tesla::Expression* Usage::release_end() {
  clear_has_end();
  ::tesla::Expression* temp = end_;
  end_ = NULL;
  return temp;
}
inline void Usage::set_allocated_end(::tesla::Expression* end) {
  delete end_;
  end_ = end;
  if (end) {
    set_has_end();
  } else {
    clear_has_end();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.Usage.end)
}

// optional bool deleted = 4 [default = false];
inline bool Usage::has_deleted() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Usage::set_has_deleted() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Usage::clear_has_deleted() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Usage::clear_deleted() {
  deleted_ = false;
  clear_has_deleted();
}
inline bool Usage::deleted() const {
  // @@protoc_insertion_point(field_get:tesla.Usage.deleted)
  return deleted_;
}
inline void Usage::set_deleted(bool value) {
  set_has_deleted();
  deleted_ = value;
  // @@protoc_insertion_point(field_set:tesla.Usage.deleted)
}

// -------------------------------------------------------------------

// AutomatonDescription

// required .tesla.Identifier identifier = 1;
inline bool AutomatonDescription::has_identifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AutomatonDescription::set_has_identifier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AutomatonDescription::clear_has_identifier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AutomatonDescription::clear_identifier() {
  if (identifier_ != NULL) identifier_->::tesla::Identifier::Clear();
  clear_has_identifier();
}
inline const ::tesla::Identifier& AutomatonDescription::identifier() const {
  // @@protoc_insertion_point(field_get:tesla.AutomatonDescription.identifier)
  return identifier_ != NULL ? *identifier_ : *default_instance_->identifier_;
}
inline ::tesla::Identifier* AutomatonDescription::mutable_identifier() {
  set_has_identifier();
  if (identifier_ == NULL) identifier_ = new ::tesla::Identifier;
  // @@protoc_insertion_point(field_mutable:tesla.AutomatonDescription.identifier)
  return identifier_;
}
inline ::tesla::Identifier* AutomatonDescription::release_identifier() {
  clear_has_identifier();
  ::tesla::Identifier* temp = identifier_;
  identifier_ = NULL;
  return temp;
}
inline void AutomatonDescription::set_allocated_identifier(::tesla::Identifier* identifier) {
  delete identifier_;
  identifier_ = identifier;
  if (identifier) {
    set_has_identifier();
  } else {
    clear_has_identifier();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.AutomatonDescription.identifier)
}

// required .tesla.AutomatonDescription.Context context = 2;
inline bool AutomatonDescription::has_context() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AutomatonDescription::set_has_context() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AutomatonDescription::clear_has_context() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AutomatonDescription::clear_context() {
  context_ = 1;
  clear_has_context();
}
inline ::tesla::AutomatonDescription_Context AutomatonDescription::context() const {
  // @@protoc_insertion_point(field_get:tesla.AutomatonDescription.context)
  return static_cast< ::tesla::AutomatonDescription_Context >(context_);
}
inline void AutomatonDescription::set_context(::tesla::AutomatonDescription_Context value) {
  assert(::tesla::AutomatonDescription_Context_IsValid(value));
  set_has_context();
  context_ = value;
  // @@protoc_insertion_point(field_set:tesla.AutomatonDescription.context)
}

// required .tesla.Expression expression = 3;
inline bool AutomatonDescription::has_expression() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AutomatonDescription::set_has_expression() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AutomatonDescription::clear_has_expression() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AutomatonDescription::clear_expression() {
  if (expression_ != NULL) expression_->::tesla::Expression::Clear();
  clear_has_expression();
}
inline const ::tesla::Expression& AutomatonDescription::expression() const {
  // @@protoc_insertion_point(field_get:tesla.AutomatonDescription.expression)
  return expression_ != NULL ? *expression_ : *default_instance_->expression_;
}
inline ::tesla::Expression* AutomatonDescription::mutable_expression() {
  set_has_expression();
  if (expression_ == NULL) expression_ = new ::tesla::Expression;
  // @@protoc_insertion_point(field_mutable:tesla.AutomatonDescription.expression)
  return expression_;
}
inline ::tesla::Expression* AutomatonDescription::release_expression() {
  clear_has_expression();
  ::tesla::Expression* temp = expression_;
  expression_ = NULL;
  return temp;
}
inline void AutomatonDescription::set_allocated_expression(::tesla::Expression* expression) {
  delete expression_;
  expression_ = expression;
  if (expression) {
    set_has_expression();
  } else {
    clear_has_expression();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.AutomatonDescription.expression)
}

// repeated .tesla.Argument argument = 5;
inline int AutomatonDescription::argument_size() const {
  return argument_.size();
}
inline void AutomatonDescription::clear_argument() {
  argument_.Clear();
}
inline const ::tesla::Argument& AutomatonDescription::argument(int index) const {
  // @@protoc_insertion_point(field_get:tesla.AutomatonDescription.argument)
  return argument_.Get(index);
}
inline ::tesla::Argument* AutomatonDescription::mutable_argument(int index) {
  // @@protoc_insertion_point(field_mutable:tesla.AutomatonDescription.argument)
  return argument_.Mutable(index);
}
inline ::tesla::Argument* AutomatonDescription::add_argument() {
  // @@protoc_insertion_point(field_add:tesla.AutomatonDescription.argument)
  return argument_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tesla::Argument >&
AutomatonDescription::argument() const {
  // @@protoc_insertion_point(field_list:tesla.AutomatonDescription.argument)
  return argument_;
}
inline ::google::protobuf::RepeatedPtrField< ::tesla::Argument >*
AutomatonDescription::mutable_argument() {
  // @@protoc_insertion_point(field_mutable_list:tesla.AutomatonDescription.argument)
  return &argument_;
}

// optional string source = 6;
inline bool AutomatonDescription::has_source() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AutomatonDescription::set_has_source() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AutomatonDescription::clear_has_source() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AutomatonDescription::clear_source() {
  if (source_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_->clear();
  }
  clear_has_source();
}
inline const ::std::string& AutomatonDescription::source() const {
  // @@protoc_insertion_point(field_get:tesla.AutomatonDescription.source)
  return *source_;
}
inline void AutomatonDescription::set_source(const ::std::string& value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  source_->assign(value);
  // @@protoc_insertion_point(field_set:tesla.AutomatonDescription.source)
}
inline void AutomatonDescription::set_source(const char* value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  source_->assign(value);
  // @@protoc_insertion_point(field_set_char:tesla.AutomatonDescription.source)
}
inline void AutomatonDescription::set_source(const char* value, size_t size) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  source_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tesla.AutomatonDescription.source)
}
inline ::std::string* AutomatonDescription::mutable_source() {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:tesla.AutomatonDescription.source)
  return source_;
}
inline ::std::string* AutomatonDescription::release_source() {
  clear_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = source_;
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void AutomatonDescription::set_allocated_source(::std::string* source) {
  if (source_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete source_;
  }
  if (source) {
    set_has_source();
    source_ = source;
  } else {
    clear_has_source();
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.AutomatonDescription.source)
}

// -------------------------------------------------------------------

// Identifier

// optional string name = 1;
inline bool Identifier::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Identifier::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Identifier::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Identifier::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Identifier::name() const {
  // @@protoc_insertion_point(field_get:tesla.Identifier.name)
  return *name_;
}
inline void Identifier::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:tesla.Identifier.name)
}
inline void Identifier::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:tesla.Identifier.name)
}
inline void Identifier::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tesla.Identifier.name)
}
inline ::std::string* Identifier::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:tesla.Identifier.name)
  return name_;
}
inline ::std::string* Identifier::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Identifier::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.Identifier.name)
}

// optional .tesla.Location location = 2;
inline bool Identifier::has_location() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Identifier::set_has_location() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Identifier::clear_has_location() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Identifier::clear_location() {
  if (location_ != NULL) location_->::tesla::Location::Clear();
  clear_has_location();
}
inline const ::tesla::Location& Identifier::location() const {
  // @@protoc_insertion_point(field_get:tesla.Identifier.location)
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::tesla::Location* Identifier::mutable_location() {
  set_has_location();
  if (location_ == NULL) location_ = new ::tesla::Location;
  // @@protoc_insertion_point(field_mutable:tesla.Identifier.location)
  return location_;
}
inline ::tesla::Location* Identifier::release_location() {
  clear_has_location();
  ::tesla::Location* temp = location_;
  location_ = NULL;
  return temp;
}
inline void Identifier::set_allocated_location(::tesla::Location* location) {
  delete location_;
  location_ = location;
  if (location) {
    set_has_location();
  } else {
    clear_has_location();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.Identifier.location)
}

// -------------------------------------------------------------------

// Location

// required string filename = 1;
inline bool Location::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Location::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Location::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Location::clear_filename() {
  if (filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& Location::filename() const {
  // @@protoc_insertion_point(field_get:tesla.Location.filename)
  return *filename_;
}
inline void Location::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
  // @@protoc_insertion_point(field_set:tesla.Location.filename)
}
inline void Location::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
  // @@protoc_insertion_point(field_set_char:tesla.Location.filename)
}
inline void Location::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tesla.Location.filename)
}
inline ::std::string* Location::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:tesla.Location.filename)
  return filename_;
}
inline ::std::string* Location::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Location::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.Location.filename)
}

// required int32 line = 2;
inline bool Location::has_line() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Location::set_has_line() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Location::clear_has_line() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Location::clear_line() {
  line_ = 0;
  clear_has_line();
}
inline ::google::protobuf::int32 Location::line() const {
  // @@protoc_insertion_point(field_get:tesla.Location.line)
  return line_;
}
inline void Location::set_line(::google::protobuf::int32 value) {
  set_has_line();
  line_ = value;
  // @@protoc_insertion_point(field_set:tesla.Location.line)
}

// required int32 counter = 3;
inline bool Location::has_counter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Location::set_has_counter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Location::clear_has_counter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Location::clear_counter() {
  counter_ = 0;
  clear_has_counter();
}
inline ::google::protobuf::int32 Location::counter() const {
  // @@protoc_insertion_point(field_get:tesla.Location.counter)
  return counter_;
}
inline void Location::set_counter(::google::protobuf::int32 value) {
  set_has_counter();
  counter_ = value;
  // @@protoc_insertion_point(field_set:tesla.Location.counter)
}

// -------------------------------------------------------------------

// Expression

// required .tesla.Expression.Type type = 1;
inline bool Expression::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Expression::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Expression::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Expression::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::tesla::Expression_Type Expression::type() const {
  // @@protoc_insertion_point(field_get:tesla.Expression.type)
  return static_cast< ::tesla::Expression_Type >(type_);
}
inline void Expression::set_type(::tesla::Expression_Type value) {
  assert(::tesla::Expression_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:tesla.Expression.type)
}

// optional .tesla.BooleanExpr booleanExpr = 2;
inline bool Expression::has_booleanexpr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Expression::set_has_booleanexpr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Expression::clear_has_booleanexpr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Expression::clear_booleanexpr() {
  if (booleanexpr_ != NULL) booleanexpr_->::tesla::BooleanExpr::Clear();
  clear_has_booleanexpr();
}
inline const ::tesla::BooleanExpr& Expression::booleanexpr() const {
  // @@protoc_insertion_point(field_get:tesla.Expression.booleanExpr)
  return booleanexpr_ != NULL ? *booleanexpr_ : *default_instance_->booleanexpr_;
}
inline ::tesla::BooleanExpr* Expression::mutable_booleanexpr() {
  set_has_booleanexpr();
  if (booleanexpr_ == NULL) booleanexpr_ = new ::tesla::BooleanExpr;
  // @@protoc_insertion_point(field_mutable:tesla.Expression.booleanExpr)
  return booleanexpr_;
}
inline ::tesla::BooleanExpr* Expression::release_booleanexpr() {
  clear_has_booleanexpr();
  ::tesla::BooleanExpr* temp = booleanexpr_;
  booleanexpr_ = NULL;
  return temp;
}
inline void Expression::set_allocated_booleanexpr(::tesla::BooleanExpr* booleanexpr) {
  delete booleanexpr_;
  booleanexpr_ = booleanexpr;
  if (booleanexpr) {
    set_has_booleanexpr();
  } else {
    clear_has_booleanexpr();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.Expression.booleanExpr)
}

// optional .tesla.Sequence sequence = 3;
inline bool Expression::has_sequence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Expression::set_has_sequence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Expression::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Expression::clear_sequence() {
  if (sequence_ != NULL) sequence_->::tesla::Sequence::Clear();
  clear_has_sequence();
}
inline const ::tesla::Sequence& Expression::sequence() const {
  // @@protoc_insertion_point(field_get:tesla.Expression.sequence)
  return sequence_ != NULL ? *sequence_ : *default_instance_->sequence_;
}
inline ::tesla::Sequence* Expression::mutable_sequence() {
  set_has_sequence();
  if (sequence_ == NULL) sequence_ = new ::tesla::Sequence;
  // @@protoc_insertion_point(field_mutable:tesla.Expression.sequence)
  return sequence_;
}
inline ::tesla::Sequence* Expression::release_sequence() {
  clear_has_sequence();
  ::tesla::Sequence* temp = sequence_;
  sequence_ = NULL;
  return temp;
}
inline void Expression::set_allocated_sequence(::tesla::Sequence* sequence) {
  delete sequence_;
  sequence_ = sequence;
  if (sequence) {
    set_has_sequence();
  } else {
    clear_has_sequence();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.Expression.sequence)
}

// optional .tesla.AssertionSite assertSite = 4;
inline bool Expression::has_assertsite() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Expression::set_has_assertsite() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Expression::clear_has_assertsite() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Expression::clear_assertsite() {
  if (assertsite_ != NULL) assertsite_->::tesla::AssertionSite::Clear();
  clear_has_assertsite();
}
inline const ::tesla::AssertionSite& Expression::assertsite() const {
  // @@protoc_insertion_point(field_get:tesla.Expression.assertSite)
  return assertsite_ != NULL ? *assertsite_ : *default_instance_->assertsite_;
}
inline ::tesla::AssertionSite* Expression::mutable_assertsite() {
  set_has_assertsite();
  if (assertsite_ == NULL) assertsite_ = new ::tesla::AssertionSite;
  // @@protoc_insertion_point(field_mutable:tesla.Expression.assertSite)
  return assertsite_;
}
inline ::tesla::AssertionSite* Expression::release_assertsite() {
  clear_has_assertsite();
  ::tesla::AssertionSite* temp = assertsite_;
  assertsite_ = NULL;
  return temp;
}
inline void Expression::set_allocated_assertsite(::tesla::AssertionSite* assertsite) {
  delete assertsite_;
  assertsite_ = assertsite;
  if (assertsite) {
    set_has_assertsite();
  } else {
    clear_has_assertsite();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.Expression.assertSite)
}

// optional .tesla.FunctionEvent function = 5;
inline bool Expression::has_function() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Expression::set_has_function() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Expression::clear_has_function() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Expression::clear_function() {
  if (function_ != NULL) function_->::tesla::FunctionEvent::Clear();
  clear_has_function();
}
inline const ::tesla::FunctionEvent& Expression::function() const {
  // @@protoc_insertion_point(field_get:tesla.Expression.function)
  return function_ != NULL ? *function_ : *default_instance_->function_;
}
inline ::tesla::FunctionEvent* Expression::mutable_function() {
  set_has_function();
  if (function_ == NULL) function_ = new ::tesla::FunctionEvent;
  // @@protoc_insertion_point(field_mutable:tesla.Expression.function)
  return function_;
}
inline ::tesla::FunctionEvent* Expression::release_function() {
  clear_has_function();
  ::tesla::FunctionEvent* temp = function_;
  function_ = NULL;
  return temp;
}
inline void Expression::set_allocated_function(::tesla::FunctionEvent* function) {
  delete function_;
  function_ = function;
  if (function) {
    set_has_function();
  } else {
    clear_has_function();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.Expression.function)
}

// optional .tesla.FieldAssignment fieldAssign = 6;
inline bool Expression::has_fieldassign() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Expression::set_has_fieldassign() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Expression::clear_has_fieldassign() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Expression::clear_fieldassign() {
  if (fieldassign_ != NULL) fieldassign_->::tesla::FieldAssignment::Clear();
  clear_has_fieldassign();
}
inline const ::tesla::FieldAssignment& Expression::fieldassign() const {
  // @@protoc_insertion_point(field_get:tesla.Expression.fieldAssign)
  return fieldassign_ != NULL ? *fieldassign_ : *default_instance_->fieldassign_;
}
inline ::tesla::FieldAssignment* Expression::mutable_fieldassign() {
  set_has_fieldassign();
  if (fieldassign_ == NULL) fieldassign_ = new ::tesla::FieldAssignment;
  // @@protoc_insertion_point(field_mutable:tesla.Expression.fieldAssign)
  return fieldassign_;
}
inline ::tesla::FieldAssignment* Expression::release_fieldassign() {
  clear_has_fieldassign();
  ::tesla::FieldAssignment* temp = fieldassign_;
  fieldassign_ = NULL;
  return temp;
}
inline void Expression::set_allocated_fieldassign(::tesla::FieldAssignment* fieldassign) {
  delete fieldassign_;
  fieldassign_ = fieldassign;
  if (fieldassign) {
    set_has_fieldassign();
  } else {
    clear_has_fieldassign();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.Expression.fieldAssign)
}

// optional .tesla.Identifier subAutomaton = 7;
inline bool Expression::has_subautomaton() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Expression::set_has_subautomaton() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Expression::clear_has_subautomaton() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Expression::clear_subautomaton() {
  if (subautomaton_ != NULL) subautomaton_->::tesla::Identifier::Clear();
  clear_has_subautomaton();
}
inline const ::tesla::Identifier& Expression::subautomaton() const {
  // @@protoc_insertion_point(field_get:tesla.Expression.subAutomaton)
  return subautomaton_ != NULL ? *subautomaton_ : *default_instance_->subautomaton_;
}
inline ::tesla::Identifier* Expression::mutable_subautomaton() {
  set_has_subautomaton();
  if (subautomaton_ == NULL) subautomaton_ = new ::tesla::Identifier;
  // @@protoc_insertion_point(field_mutable:tesla.Expression.subAutomaton)
  return subautomaton_;
}
inline ::tesla::Identifier* Expression::release_subautomaton() {
  clear_has_subautomaton();
  ::tesla::Identifier* temp = subautomaton_;
  subautomaton_ = NULL;
  return temp;
}
inline void Expression::set_allocated_subautomaton(::tesla::Identifier* subautomaton) {
  delete subautomaton_;
  subautomaton_ = subautomaton;
  if (subautomaton) {
    set_has_subautomaton();
  } else {
    clear_has_subautomaton();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.Expression.subAutomaton)
}

// -------------------------------------------------------------------

// BooleanExpr

// required .tesla.BooleanExpr.Operation operation = 1;
inline bool BooleanExpr::has_operation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BooleanExpr::set_has_operation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BooleanExpr::clear_has_operation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BooleanExpr::clear_operation() {
  operation_ = 1;
  clear_has_operation();
}
inline ::tesla::BooleanExpr_Operation BooleanExpr::operation() const {
  // @@protoc_insertion_point(field_get:tesla.BooleanExpr.operation)
  return static_cast< ::tesla::BooleanExpr_Operation >(operation_);
}
inline void BooleanExpr::set_operation(::tesla::BooleanExpr_Operation value) {
  assert(::tesla::BooleanExpr_Operation_IsValid(value));
  set_has_operation();
  operation_ = value;
  // @@protoc_insertion_point(field_set:tesla.BooleanExpr.operation)
}

// repeated .tesla.Expression expression = 2;
inline int BooleanExpr::expression_size() const {
  return expression_.size();
}
inline void BooleanExpr::clear_expression() {
  expression_.Clear();
}
inline const ::tesla::Expression& BooleanExpr::expression(int index) const {
  // @@protoc_insertion_point(field_get:tesla.BooleanExpr.expression)
  return expression_.Get(index);
}
inline ::tesla::Expression* BooleanExpr::mutable_expression(int index) {
  // @@protoc_insertion_point(field_mutable:tesla.BooleanExpr.expression)
  return expression_.Mutable(index);
}
inline ::tesla::Expression* BooleanExpr::add_expression() {
  // @@protoc_insertion_point(field_add:tesla.BooleanExpr.expression)
  return expression_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tesla::Expression >&
BooleanExpr::expression() const {
  // @@protoc_insertion_point(field_list:tesla.BooleanExpr.expression)
  return expression_;
}
inline ::google::protobuf::RepeatedPtrField< ::tesla::Expression >*
BooleanExpr::mutable_expression() {
  // @@protoc_insertion_point(field_mutable_list:tesla.BooleanExpr.expression)
  return &expression_;
}

// -------------------------------------------------------------------

// Sequence

// repeated .tesla.Expression expression = 1;
inline int Sequence::expression_size() const {
  return expression_.size();
}
inline void Sequence::clear_expression() {
  expression_.Clear();
}
inline const ::tesla::Expression& Sequence::expression(int index) const {
  // @@protoc_insertion_point(field_get:tesla.Sequence.expression)
  return expression_.Get(index);
}
inline ::tesla::Expression* Sequence::mutable_expression(int index) {
  // @@protoc_insertion_point(field_mutable:tesla.Sequence.expression)
  return expression_.Mutable(index);
}
inline ::tesla::Expression* Sequence::add_expression() {
  // @@protoc_insertion_point(field_add:tesla.Sequence.expression)
  return expression_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tesla::Expression >&
Sequence::expression() const {
  // @@protoc_insertion_point(field_list:tesla.Sequence.expression)
  return expression_;
}
inline ::google::protobuf::RepeatedPtrField< ::tesla::Expression >*
Sequence::mutable_expression() {
  // @@protoc_insertion_point(field_mutable_list:tesla.Sequence.expression)
  return &expression_;
}

// optional int32 minReps = 2 [default = 1];
inline bool Sequence::has_minreps() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Sequence::set_has_minreps() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Sequence::clear_has_minreps() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Sequence::clear_minreps() {
  minreps_ = 1;
  clear_has_minreps();
}
inline ::google::protobuf::int32 Sequence::minreps() const {
  // @@protoc_insertion_point(field_get:tesla.Sequence.minReps)
  return minreps_;
}
inline void Sequence::set_minreps(::google::protobuf::int32 value) {
  set_has_minreps();
  minreps_ = value;
  // @@protoc_insertion_point(field_set:tesla.Sequence.minReps)
}

// optional int32 maxReps = 3 [default = 1];
inline bool Sequence::has_maxreps() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Sequence::set_has_maxreps() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Sequence::clear_has_maxreps() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Sequence::clear_maxreps() {
  maxreps_ = 1;
  clear_has_maxreps();
}
inline ::google::protobuf::int32 Sequence::maxreps() const {
  // @@protoc_insertion_point(field_get:tesla.Sequence.maxReps)
  return maxreps_;
}
inline void Sequence::set_maxreps(::google::protobuf::int32 value) {
  set_has_maxreps();
  maxreps_ = value;
  // @@protoc_insertion_point(field_set:tesla.Sequence.maxReps)
}

// -------------------------------------------------------------------

// AssertionSite

// required .tesla.Location location = 1;
inline bool AssertionSite::has_location() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AssertionSite::set_has_location() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AssertionSite::clear_has_location() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AssertionSite::clear_location() {
  if (location_ != NULL) location_->::tesla::Location::Clear();
  clear_has_location();
}
inline const ::tesla::Location& AssertionSite::location() const {
  // @@protoc_insertion_point(field_get:tesla.AssertionSite.location)
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::tesla::Location* AssertionSite::mutable_location() {
  set_has_location();
  if (location_ == NULL) location_ = new ::tesla::Location;
  // @@protoc_insertion_point(field_mutable:tesla.AssertionSite.location)
  return location_;
}
inline ::tesla::Location* AssertionSite::release_location() {
  clear_has_location();
  ::tesla::Location* temp = location_;
  location_ = NULL;
  return temp;
}
inline void AssertionSite::set_allocated_location(::tesla::Location* location) {
  delete location_;
  location_ = location;
  if (location) {
    set_has_location();
  } else {
    clear_has_location();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.AssertionSite.location)
}

// -------------------------------------------------------------------

// FunctionEvent

// required .tesla.FunctionRef function = 1;
inline bool FunctionEvent::has_function() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FunctionEvent::set_has_function() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FunctionEvent::clear_has_function() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FunctionEvent::clear_function() {
  if (function_ != NULL) function_->::tesla::FunctionRef::Clear();
  clear_has_function();
}
inline const ::tesla::FunctionRef& FunctionEvent::function() const {
  // @@protoc_insertion_point(field_get:tesla.FunctionEvent.function)
  return function_ != NULL ? *function_ : *default_instance_->function_;
}
inline ::tesla::FunctionRef* FunctionEvent::mutable_function() {
  set_has_function();
  if (function_ == NULL) function_ = new ::tesla::FunctionRef;
  // @@protoc_insertion_point(field_mutable:tesla.FunctionEvent.function)
  return function_;
}
inline ::tesla::FunctionRef* FunctionEvent::release_function() {
  clear_has_function();
  ::tesla::FunctionRef* temp = function_;
  function_ = NULL;
  return temp;
}
inline void FunctionEvent::set_allocated_function(::tesla::FunctionRef* function) {
  delete function_;
  function_ = function;
  if (function) {
    set_has_function();
  } else {
    clear_has_function();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.FunctionEvent.function)
}

// optional .tesla.FunctionEvent.Direction direction = 2;
inline bool FunctionEvent::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FunctionEvent::set_has_direction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FunctionEvent::clear_has_direction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FunctionEvent::clear_direction() {
  direction_ = 1;
  clear_has_direction();
}
inline ::tesla::FunctionEvent_Direction FunctionEvent::direction() const {
  // @@protoc_insertion_point(field_get:tesla.FunctionEvent.direction)
  return static_cast< ::tesla::FunctionEvent_Direction >(direction_);
}
inline void FunctionEvent::set_direction(::tesla::FunctionEvent_Direction value) {
  assert(::tesla::FunctionEvent_Direction_IsValid(value));
  set_has_direction();
  direction_ = value;
  // @@protoc_insertion_point(field_set:tesla.FunctionEvent.direction)
}

// optional .tesla.FunctionEvent.CallContext context = 3;
inline bool FunctionEvent::has_context() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FunctionEvent::set_has_context() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FunctionEvent::clear_has_context() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FunctionEvent::clear_context() {
  context_ = 1;
  clear_has_context();
}
inline ::tesla::FunctionEvent_CallContext FunctionEvent::context() const {
  // @@protoc_insertion_point(field_get:tesla.FunctionEvent.context)
  return static_cast< ::tesla::FunctionEvent_CallContext >(context_);
}
inline void FunctionEvent::set_context(::tesla::FunctionEvent_CallContext value) {
  assert(::tesla::FunctionEvent_CallContext_IsValid(value));
  set_has_context();
  context_ = value;
  // @@protoc_insertion_point(field_set:tesla.FunctionEvent.context)
}

// repeated .tesla.Argument argument = 4;
inline int FunctionEvent::argument_size() const {
  return argument_.size();
}
inline void FunctionEvent::clear_argument() {
  argument_.Clear();
}
inline const ::tesla::Argument& FunctionEvent::argument(int index) const {
  // @@protoc_insertion_point(field_get:tesla.FunctionEvent.argument)
  return argument_.Get(index);
}
inline ::tesla::Argument* FunctionEvent::mutable_argument(int index) {
  // @@protoc_insertion_point(field_mutable:tesla.FunctionEvent.argument)
  return argument_.Mutable(index);
}
inline ::tesla::Argument* FunctionEvent::add_argument() {
  // @@protoc_insertion_point(field_add:tesla.FunctionEvent.argument)
  return argument_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tesla::Argument >&
FunctionEvent::argument() const {
  // @@protoc_insertion_point(field_list:tesla.FunctionEvent.argument)
  return argument_;
}
inline ::google::protobuf::RepeatedPtrField< ::tesla::Argument >*
FunctionEvent::mutable_argument() {
  // @@protoc_insertion_point(field_mutable_list:tesla.FunctionEvent.argument)
  return &argument_;
}

// optional .tesla.Argument expectedReturnValue = 5;
inline bool FunctionEvent::has_expectedreturnvalue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FunctionEvent::set_has_expectedreturnvalue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FunctionEvent::clear_has_expectedreturnvalue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FunctionEvent::clear_expectedreturnvalue() {
  if (expectedreturnvalue_ != NULL) expectedreturnvalue_->::tesla::Argument::Clear();
  clear_has_expectedreturnvalue();
}
inline const ::tesla::Argument& FunctionEvent::expectedreturnvalue() const {
  // @@protoc_insertion_point(field_get:tesla.FunctionEvent.expectedReturnValue)
  return expectedreturnvalue_ != NULL ? *expectedreturnvalue_ : *default_instance_->expectedreturnvalue_;
}
inline ::tesla::Argument* FunctionEvent::mutable_expectedreturnvalue() {
  set_has_expectedreturnvalue();
  if (expectedreturnvalue_ == NULL) expectedreturnvalue_ = new ::tesla::Argument;
  // @@protoc_insertion_point(field_mutable:tesla.FunctionEvent.expectedReturnValue)
  return expectedreturnvalue_;
}
inline ::tesla::Argument* FunctionEvent::release_expectedreturnvalue() {
  clear_has_expectedreturnvalue();
  ::tesla::Argument* temp = expectedreturnvalue_;
  expectedreturnvalue_ = NULL;
  return temp;
}
inline void FunctionEvent::set_allocated_expectedreturnvalue(::tesla::Argument* expectedreturnvalue) {
  delete expectedreturnvalue_;
  expectedreturnvalue_ = expectedreturnvalue;
  if (expectedreturnvalue) {
    set_has_expectedreturnvalue();
  } else {
    clear_has_expectedreturnvalue();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.FunctionEvent.expectedReturnValue)
}

// optional bool strict = 6 [default = true];
inline bool FunctionEvent::has_strict() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FunctionEvent::set_has_strict() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FunctionEvent::clear_has_strict() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FunctionEvent::clear_strict() {
  strict_ = true;
  clear_has_strict();
}
inline bool FunctionEvent::strict() const {
  // @@protoc_insertion_point(field_get:tesla.FunctionEvent.strict)
  return strict_;
}
inline void FunctionEvent::set_strict(bool value) {
  set_has_strict();
  strict_ = value;
  // @@protoc_insertion_point(field_set:tesla.FunctionEvent.strict)
}

// optional .tesla.FunctionEvent.CallKind kind = 7 [default = CCall];
inline bool FunctionEvent::has_kind() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FunctionEvent::set_has_kind() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FunctionEvent::clear_has_kind() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FunctionEvent::clear_kind() {
  kind_ = 1;
  clear_has_kind();
}
inline ::tesla::FunctionEvent_CallKind FunctionEvent::kind() const {
  // @@protoc_insertion_point(field_get:tesla.FunctionEvent.kind)
  return static_cast< ::tesla::FunctionEvent_CallKind >(kind_);
}
inline void FunctionEvent::set_kind(::tesla::FunctionEvent_CallKind value) {
  assert(::tesla::FunctionEvent_CallKind_IsValid(value));
  set_has_kind();
  kind_ = value;
  // @@protoc_insertion_point(field_set:tesla.FunctionEvent.kind)
}

// optional .tesla.Argument receiver = 8;
inline bool FunctionEvent::has_receiver() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FunctionEvent::set_has_receiver() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FunctionEvent::clear_has_receiver() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FunctionEvent::clear_receiver() {
  if (receiver_ != NULL) receiver_->::tesla::Argument::Clear();
  clear_has_receiver();
}
inline const ::tesla::Argument& FunctionEvent::receiver() const {
  // @@protoc_insertion_point(field_get:tesla.FunctionEvent.receiver)
  return receiver_ != NULL ? *receiver_ : *default_instance_->receiver_;
}
inline ::tesla::Argument* FunctionEvent::mutable_receiver() {
  set_has_receiver();
  if (receiver_ == NULL) receiver_ = new ::tesla::Argument;
  // @@protoc_insertion_point(field_mutable:tesla.FunctionEvent.receiver)
  return receiver_;
}
inline ::tesla::Argument* FunctionEvent::release_receiver() {
  clear_has_receiver();
  ::tesla::Argument* temp = receiver_;
  receiver_ = NULL;
  return temp;
}
inline void FunctionEvent::set_allocated_receiver(::tesla::Argument* receiver) {
  delete receiver_;
  receiver_ = receiver;
  if (receiver) {
    set_has_receiver();
  } else {
    clear_has_receiver();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.FunctionEvent.receiver)
}

// -------------------------------------------------------------------

// FunctionRef

// required string name = 1;
inline bool FunctionRef::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FunctionRef::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FunctionRef::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FunctionRef::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& FunctionRef::name() const {
  // @@protoc_insertion_point(field_get:tesla.FunctionRef.name)
  return *name_;
}
inline void FunctionRef::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:tesla.FunctionRef.name)
}
inline void FunctionRef::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:tesla.FunctionRef.name)
}
inline void FunctionRef::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tesla.FunctionRef.name)
}
inline ::std::string* FunctionRef::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:tesla.FunctionRef.name)
  return name_;
}
inline ::std::string* FunctionRef::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FunctionRef::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.FunctionRef.name)
}

// -------------------------------------------------------------------

// FieldAssignment

// required .tesla.StructField field = 8;
inline bool FieldAssignment::has_field() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FieldAssignment::set_has_field() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FieldAssignment::clear_has_field() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FieldAssignment::clear_field() {
  if (field_ != NULL) field_->::tesla::StructField::Clear();
  clear_has_field();
}
inline const ::tesla::StructField& FieldAssignment::field() const {
  // @@protoc_insertion_point(field_get:tesla.FieldAssignment.field)
  return field_ != NULL ? *field_ : *default_instance_->field_;
}
inline ::tesla::StructField* FieldAssignment::mutable_field() {
  set_has_field();
  if (field_ == NULL) field_ = new ::tesla::StructField;
  // @@protoc_insertion_point(field_mutable:tesla.FieldAssignment.field)
  return field_;
}
inline ::tesla::StructField* FieldAssignment::release_field() {
  clear_has_field();
  ::tesla::StructField* temp = field_;
  field_ = NULL;
  return temp;
}
inline void FieldAssignment::set_allocated_field(::tesla::StructField* field) {
  delete field_;
  field_ = field;
  if (field) {
    set_has_field();
  } else {
    clear_has_field();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.FieldAssignment.field)
}

// required .tesla.FieldAssignment.AssignType operation = 4;
inline bool FieldAssignment::has_operation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FieldAssignment::set_has_operation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FieldAssignment::clear_has_operation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FieldAssignment::clear_operation() {
  operation_ = 1;
  clear_has_operation();
}
inline ::tesla::FieldAssignment_AssignType FieldAssignment::operation() const {
  // @@protoc_insertion_point(field_get:tesla.FieldAssignment.operation)
  return static_cast< ::tesla::FieldAssignment_AssignType >(operation_);
}
inline void FieldAssignment::set_operation(::tesla::FieldAssignment_AssignType value) {
  assert(::tesla::FieldAssignment_AssignType_IsValid(value));
  set_has_operation();
  operation_ = value;
  // @@protoc_insertion_point(field_set:tesla.FieldAssignment.operation)
}

// required .tesla.Argument value = 5;
inline bool FieldAssignment::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FieldAssignment::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FieldAssignment::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FieldAssignment::clear_value() {
  if (value_ != NULL) value_->::tesla::Argument::Clear();
  clear_has_value();
}
inline const ::tesla::Argument& FieldAssignment::value() const {
  // @@protoc_insertion_point(field_get:tesla.FieldAssignment.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::tesla::Argument* FieldAssignment::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::tesla::Argument;
  // @@protoc_insertion_point(field_mutable:tesla.FieldAssignment.value)
  return value_;
}
inline ::tesla::Argument* FieldAssignment::release_value() {
  clear_has_value();
  ::tesla::Argument* temp = value_;
  value_ = NULL;
  return temp;
}
inline void FieldAssignment::set_allocated_value(::tesla::Argument* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.FieldAssignment.value)
}

// optional bool strict = 7 [default = true];
inline bool FieldAssignment::has_strict() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FieldAssignment::set_has_strict() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FieldAssignment::clear_has_strict() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FieldAssignment::clear_strict() {
  strict_ = true;
  clear_has_strict();
}
inline bool FieldAssignment::strict() const {
  // @@protoc_insertion_point(field_get:tesla.FieldAssignment.strict)
  return strict_;
}
inline void FieldAssignment::set_strict(bool value) {
  set_has_strict();
  strict_ = value;
  // @@protoc_insertion_point(field_set:tesla.FieldAssignment.strict)
}

// -------------------------------------------------------------------

// StructField

// required string type = 1;
inline bool StructField::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StructField::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StructField::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StructField::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& StructField::type() const {
  // @@protoc_insertion_point(field_get:tesla.StructField.type)
  return *type_;
}
inline void StructField::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:tesla.StructField.type)
}
inline void StructField::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:tesla.StructField.type)
}
inline void StructField::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tesla.StructField.type)
}
inline ::std::string* StructField::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:tesla.StructField.type)
  return type_;
}
inline ::std::string* StructField::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StructField::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.StructField.type)
}

// required .tesla.Argument base = 2;
inline bool StructField::has_base() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StructField::set_has_base() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StructField::clear_has_base() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StructField::clear_base() {
  if (base_ != NULL) base_->::tesla::Argument::Clear();
  clear_has_base();
}
inline const ::tesla::Argument& StructField::base() const {
  // @@protoc_insertion_point(field_get:tesla.StructField.base)
  return base_ != NULL ? *base_ : *default_instance_->base_;
}
inline ::tesla::Argument* StructField::mutable_base() {
  set_has_base();
  if (base_ == NULL) base_ = new ::tesla::Argument;
  // @@protoc_insertion_point(field_mutable:tesla.StructField.base)
  return base_;
}
inline ::tesla::Argument* StructField::release_base() {
  clear_has_base();
  ::tesla::Argument* temp = base_;
  base_ = NULL;
  return temp;
}
inline void StructField::set_allocated_base(::tesla::Argument* base) {
  delete base_;
  base_ = base;
  if (base) {
    set_has_base();
  } else {
    clear_has_base();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.StructField.base)
}

// required string name = 3;
inline bool StructField::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StructField::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StructField::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StructField::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& StructField::name() const {
  // @@protoc_insertion_point(field_get:tesla.StructField.name)
  return *name_;
}
inline void StructField::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:tesla.StructField.name)
}
inline void StructField::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:tesla.StructField.name)
}
inline void StructField::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tesla.StructField.name)
}
inline ::std::string* StructField::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:tesla.StructField.name)
  return name_;
}
inline ::std::string* StructField::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StructField::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.StructField.name)
}

// required int32 index = 4;
inline bool StructField::has_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StructField::set_has_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StructField::clear_has_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StructField::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 StructField::index() const {
  // @@protoc_insertion_point(field_get:tesla.StructField.index)
  return index_;
}
inline void StructField::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:tesla.StructField.index)
}

// -------------------------------------------------------------------

// Argument

// required .tesla.Argument.Type type = 1;
inline bool Argument::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Argument::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Argument::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Argument::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::tesla::Argument_Type Argument::type() const {
  // @@protoc_insertion_point(field_get:tesla.Argument.type)
  return static_cast< ::tesla::Argument_Type >(type_);
}
inline void Argument::set_type(::tesla::Argument_Type value) {
  assert(::tesla::Argument_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:tesla.Argument.type)
}

// optional int32 index = 2;
inline bool Argument::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Argument::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Argument::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Argument::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 Argument::index() const {
  // @@protoc_insertion_point(field_get:tesla.Argument.index)
  return index_;
}
inline void Argument::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:tesla.Argument.index)
}

// optional string name = 3;
inline bool Argument::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Argument::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Argument::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Argument::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Argument::name() const {
  // @@protoc_insertion_point(field_get:tesla.Argument.name)
  return *name_;
}
inline void Argument::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:tesla.Argument.name)
}
inline void Argument::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:tesla.Argument.name)
}
inline void Argument::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tesla.Argument.name)
}
inline ::std::string* Argument::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:tesla.Argument.name)
  return name_;
}
inline ::std::string* Argument::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Argument::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.Argument.name)
}

// optional bool free = 9 [default = false];
inline bool Argument::has_free() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Argument::set_has_free() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Argument::clear_has_free() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Argument::clear_free() {
  free_ = false;
  clear_has_free();
}
inline bool Argument::free() const {
  // @@protoc_insertion_point(field_get:tesla.Argument.free)
  return free_;
}
inline void Argument::set_free(bool value) {
  set_has_free();
  free_ = value;
  // @@protoc_insertion_point(field_set:tesla.Argument.free)
}

// optional int64 value = 5;
inline bool Argument::has_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Argument::set_has_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Argument::clear_has_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Argument::clear_value() {
  value_ = GOOGLE_LONGLONG(0);
  clear_has_value();
}
inline ::google::protobuf::int64 Argument::value() const {
  // @@protoc_insertion_point(field_get:tesla.Argument.value)
  return value_;
}
inline void Argument::set_value(::google::protobuf::int64 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:tesla.Argument.value)
}

// optional .tesla.Argument.MatchType constantMatch = 6 [default = Exact];
inline bool Argument::has_constantmatch() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Argument::set_has_constantmatch() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Argument::clear_has_constantmatch() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Argument::clear_constantmatch() {
  constantmatch_ = 1;
  clear_has_constantmatch();
}
inline ::tesla::Argument_MatchType Argument::constantmatch() const {
  // @@protoc_insertion_point(field_get:tesla.Argument.constantMatch)
  return static_cast< ::tesla::Argument_MatchType >(constantmatch_);
}
inline void Argument::set_constantmatch(::tesla::Argument_MatchType value) {
  assert(::tesla::Argument_MatchType_IsValid(value));
  set_has_constantmatch();
  constantmatch_ = value;
  // @@protoc_insertion_point(field_set:tesla.Argument.constantMatch)
}

// optional .tesla.Argument indirection = 7;
inline bool Argument::has_indirection() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Argument::set_has_indirection() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Argument::clear_has_indirection() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Argument::clear_indirection() {
  if (indirection_ != NULL) indirection_->::tesla::Argument::Clear();
  clear_has_indirection();
}
inline const ::tesla::Argument& Argument::indirection() const {
  // @@protoc_insertion_point(field_get:tesla.Argument.indirection)
  return indirection_ != NULL ? *indirection_ : *default_instance_->indirection_;
}
inline ::tesla::Argument* Argument::mutable_indirection() {
  set_has_indirection();
  if (indirection_ == NULL) indirection_ = new ::tesla::Argument;
  // @@protoc_insertion_point(field_mutable:tesla.Argument.indirection)
  return indirection_;
}
inline ::tesla::Argument* Argument::release_indirection() {
  clear_has_indirection();
  ::tesla::Argument* temp = indirection_;
  indirection_ = NULL;
  return temp;
}
inline void Argument::set_allocated_indirection(::tesla::Argument* indirection) {
  delete indirection_;
  indirection_ = indirection;
  if (indirection) {
    set_has_indirection();
  } else {
    clear_has_indirection();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.Argument.indirection)
}

// optional .tesla.StructField field = 8;
inline bool Argument::has_field() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Argument::set_has_field() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Argument::clear_has_field() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Argument::clear_field() {
  if (field_ != NULL) field_->::tesla::StructField::Clear();
  clear_has_field();
}
inline const ::tesla::StructField& Argument::field() const {
  // @@protoc_insertion_point(field_get:tesla.Argument.field)
  return field_ != NULL ? *field_ : *default_instance_->field_;
}
inline ::tesla::StructField* Argument::mutable_field() {
  set_has_field();
  if (field_ == NULL) field_ = new ::tesla::StructField;
  // @@protoc_insertion_point(field_mutable:tesla.Argument.field)
  return field_;
}
inline ::tesla::StructField* Argument::release_field() {
  clear_has_field();
  ::tesla::StructField* temp = field_;
  field_ = NULL;
  return temp;
}
inline void Argument::set_allocated_field(::tesla::StructField* field) {
  delete field_;
  field_ = field;
  if (field) {
    set_has_field();
  } else {
    clear_has_field();
  }
  // @@protoc_insertion_point(field_set_allocated:tesla.Argument.field)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace tesla

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::tesla::AutomatonDescription_Context> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tesla::AutomatonDescription_Context>() {
  return ::tesla::AutomatonDescription_Context_descriptor();
}
template <> struct is_proto_enum< ::tesla::Expression_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tesla::Expression_Type>() {
  return ::tesla::Expression_Type_descriptor();
}
template <> struct is_proto_enum< ::tesla::BooleanExpr_Operation> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tesla::BooleanExpr_Operation>() {
  return ::tesla::BooleanExpr_Operation_descriptor();
}
template <> struct is_proto_enum< ::tesla::FunctionEvent_Direction> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tesla::FunctionEvent_Direction>() {
  return ::tesla::FunctionEvent_Direction_descriptor();
}
template <> struct is_proto_enum< ::tesla::FunctionEvent_CallContext> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tesla::FunctionEvent_CallContext>() {
  return ::tesla::FunctionEvent_CallContext_descriptor();
}
template <> struct is_proto_enum< ::tesla::FunctionEvent_CallKind> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tesla::FunctionEvent_CallKind>() {
  return ::tesla::FunctionEvent_CallKind_descriptor();
}
template <> struct is_proto_enum< ::tesla::FieldAssignment_AssignType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tesla::FieldAssignment_AssignType>() {
  return ::tesla::FieldAssignment_AssignType_descriptor();
}
template <> struct is_proto_enum< ::tesla::Argument_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tesla::Argument_Type>() {
  return ::tesla::Argument_Type_descriptor();
}
template <> struct is_proto_enum< ::tesla::Argument_MatchType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tesla::Argument_MatchType>() {
  return ::tesla::Argument_MatchType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tesla_2eproto__INCLUDED
