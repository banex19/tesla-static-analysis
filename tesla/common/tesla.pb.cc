// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tesla.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "tesla.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace tesla {

namespace {

const ::google::protobuf::Descriptor* ManifestFile_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ManifestFile_reflection_ = NULL;
const ::google::protobuf::Descriptor* Usage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Usage_reflection_ = NULL;
const ::google::protobuf::Descriptor* AutomatonDescription_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AutomatonDescription_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* AutomatonDescription_Context_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Identifier_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Identifier_reflection_ = NULL;
const ::google::protobuf::Descriptor* Location_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Location_reflection_ = NULL;
const ::google::protobuf::Descriptor* Expression_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Expression_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Expression_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* BooleanExpr_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BooleanExpr_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* BooleanExpr_Operation_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Sequence_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Sequence_reflection_ = NULL;
const ::google::protobuf::Descriptor* AssertionSite_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AssertionSite_reflection_ = NULL;
const ::google::protobuf::Descriptor* FunctionEvent_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FunctionEvent_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* FunctionEvent_Direction_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* FunctionEvent_CallContext_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* FunctionEvent_CallKind_descriptor_ = NULL;
const ::google::protobuf::Descriptor* FunctionRef_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FunctionRef_reflection_ = NULL;
const ::google::protobuf::Descriptor* FieldAssignment_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FieldAssignment_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* FieldAssignment_AssignType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* StructField_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StructField_reflection_ = NULL;
const ::google::protobuf::Descriptor* Argument_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Argument_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Argument_Type_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Argument_MatchType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_tesla_2eproto() {
  protobuf_AddDesc_tesla_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "tesla.proto");
  GOOGLE_CHECK(file != NULL);
  ManifestFile_descriptor_ = file->message_type(0);
  static const int ManifestFile_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ManifestFile, automaton_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ManifestFile, root_),
  };
  ManifestFile_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ManifestFile_descriptor_,
      ManifestFile::default_instance_,
      ManifestFile_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ManifestFile, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ManifestFile, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ManifestFile));
  Usage_descriptor_ = file->message_type(1);
  static const int Usage_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Usage, identifier_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Usage, beginning_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Usage, end_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Usage, deleted_),
  };
  Usage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Usage_descriptor_,
      Usage::default_instance_,
      Usage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Usage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Usage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Usage));
  AutomatonDescription_descriptor_ = file->message_type(2);
  static const int AutomatonDescription_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AutomatonDescription, identifier_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AutomatonDescription, context_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AutomatonDescription, expression_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AutomatonDescription, argument_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AutomatonDescription, source_),
  };
  AutomatonDescription_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AutomatonDescription_descriptor_,
      AutomatonDescription::default_instance_,
      AutomatonDescription_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AutomatonDescription, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AutomatonDescription, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AutomatonDescription));
  AutomatonDescription_Context_descriptor_ = AutomatonDescription_descriptor_->enum_type(0);
  Identifier_descriptor_ = file->message_type(3);
  static const int Identifier_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Identifier, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Identifier, location_),
  };
  Identifier_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Identifier_descriptor_,
      Identifier::default_instance_,
      Identifier_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Identifier, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Identifier, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Identifier));
  Location_descriptor_ = file->message_type(4);
  static const int Location_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Location, filename_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Location, line_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Location, counter_),
  };
  Location_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Location_descriptor_,
      Location::default_instance_,
      Location_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Location, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Location, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Location));
  Expression_descriptor_ = file->message_type(5);
  static const int Expression_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Expression, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Expression, booleanexpr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Expression, sequence_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Expression, assertsite_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Expression, function_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Expression, fieldassign_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Expression, subautomaton_),
  };
  Expression_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Expression_descriptor_,
      Expression::default_instance_,
      Expression_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Expression, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Expression, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Expression));
  Expression_Type_descriptor_ = Expression_descriptor_->enum_type(0);
  BooleanExpr_descriptor_ = file->message_type(6);
  static const int BooleanExpr_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BooleanExpr, operation_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BooleanExpr, expression_),
  };
  BooleanExpr_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BooleanExpr_descriptor_,
      BooleanExpr::default_instance_,
      BooleanExpr_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BooleanExpr, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BooleanExpr, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BooleanExpr));
  BooleanExpr_Operation_descriptor_ = BooleanExpr_descriptor_->enum_type(0);
  Sequence_descriptor_ = file->message_type(7);
  static const int Sequence_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sequence, expression_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sequence, minreps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sequence, maxreps_),
  };
  Sequence_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Sequence_descriptor_,
      Sequence::default_instance_,
      Sequence_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sequence, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sequence, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Sequence));
  AssertionSite_descriptor_ = file->message_type(8);
  static const int AssertionSite_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AssertionSite, location_),
  };
  AssertionSite_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AssertionSite_descriptor_,
      AssertionSite::default_instance_,
      AssertionSite_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AssertionSite, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AssertionSite, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AssertionSite));
  FunctionEvent_descriptor_ = file->message_type(9);
  static const int FunctionEvent_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FunctionEvent, function_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FunctionEvent, direction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FunctionEvent, context_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FunctionEvent, argument_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FunctionEvent, expectedreturnvalue_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FunctionEvent, strict_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FunctionEvent, kind_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FunctionEvent, receiver_),
  };
  FunctionEvent_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FunctionEvent_descriptor_,
      FunctionEvent::default_instance_,
      FunctionEvent_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FunctionEvent, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FunctionEvent, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FunctionEvent));
  FunctionEvent_Direction_descriptor_ = FunctionEvent_descriptor_->enum_type(0);
  FunctionEvent_CallContext_descriptor_ = FunctionEvent_descriptor_->enum_type(1);
  FunctionEvent_CallKind_descriptor_ = FunctionEvent_descriptor_->enum_type(2);
  FunctionRef_descriptor_ = file->message_type(10);
  static const int FunctionRef_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FunctionRef, name_),
  };
  FunctionRef_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FunctionRef_descriptor_,
      FunctionRef::default_instance_,
      FunctionRef_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FunctionRef, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FunctionRef, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FunctionRef));
  FieldAssignment_descriptor_ = file->message_type(11);
  static const int FieldAssignment_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FieldAssignment, field_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FieldAssignment, operation_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FieldAssignment, value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FieldAssignment, strict_),
  };
  FieldAssignment_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FieldAssignment_descriptor_,
      FieldAssignment::default_instance_,
      FieldAssignment_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FieldAssignment, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FieldAssignment, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FieldAssignment));
  FieldAssignment_AssignType_descriptor_ = FieldAssignment_descriptor_->enum_type(0);
  StructField_descriptor_ = file->message_type(12);
  static const int StructField_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StructField, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StructField, base_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StructField, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StructField, index_),
  };
  StructField_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      StructField_descriptor_,
      StructField::default_instance_,
      StructField_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StructField, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StructField, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(StructField));
  Argument_descriptor_ = file->message_type(13);
  static const int Argument_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Argument, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Argument, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Argument, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Argument, free_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Argument, value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Argument, constantmatch_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Argument, indirection_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Argument, field_),
  };
  Argument_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Argument_descriptor_,
      Argument::default_instance_,
      Argument_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Argument, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Argument, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Argument));
  Argument_Type_descriptor_ = Argument_descriptor_->enum_type(0);
  Argument_MatchType_descriptor_ = Argument_descriptor_->enum_type(1);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_tesla_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ManifestFile_descriptor_, &ManifestFile::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Usage_descriptor_, &Usage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AutomatonDescription_descriptor_, &AutomatonDescription::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Identifier_descriptor_, &Identifier::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Location_descriptor_, &Location::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Expression_descriptor_, &Expression::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BooleanExpr_descriptor_, &BooleanExpr::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Sequence_descriptor_, &Sequence::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AssertionSite_descriptor_, &AssertionSite::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FunctionEvent_descriptor_, &FunctionEvent::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FunctionRef_descriptor_, &FunctionRef::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FieldAssignment_descriptor_, &FieldAssignment::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    StructField_descriptor_, &StructField::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Argument_descriptor_, &Argument::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_tesla_2eproto() {
  delete ManifestFile::default_instance_;
  delete ManifestFile_reflection_;
  delete Usage::default_instance_;
  delete Usage_reflection_;
  delete AutomatonDescription::default_instance_;
  delete AutomatonDescription_reflection_;
  delete Identifier::default_instance_;
  delete Identifier_reflection_;
  delete Location::default_instance_;
  delete Location_reflection_;
  delete Expression::default_instance_;
  delete Expression_reflection_;
  delete BooleanExpr::default_instance_;
  delete BooleanExpr_reflection_;
  delete Sequence::default_instance_;
  delete Sequence_reflection_;
  delete AssertionSite::default_instance_;
  delete AssertionSite_reflection_;
  delete FunctionEvent::default_instance_;
  delete FunctionEvent_reflection_;
  delete FunctionRef::default_instance_;
  delete FunctionRef_reflection_;
  delete FieldAssignment::default_instance_;
  delete FieldAssignment_reflection_;
  delete StructField::default_instance_;
  delete StructField_reflection_;
  delete Argument::default_instance_;
  delete Argument_reflection_;
}

void protobuf_AddDesc_tesla_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\013tesla.proto\022\005tesla\"Z\n\014ManifestFile\022.\n\t"
    "automaton\030\001 \003(\0132\033.tesla.AutomatonDescrip"
    "tion\022\032\n\004root\030\002 \003(\0132\014.tesla.Usage\"\214\001\n\005Usa"
    "ge\022%\n\nidentifier\030\001 \002(\0132\021.tesla.Identifie"
    "r\022$\n\tbeginning\030\002 \001(\0132\021.tesla.Expression\022"
    "\036\n\003end\030\003 \001(\0132\021.tesla.Expression\022\026\n\007delet"
    "ed\030\004 \001(\010:\005false\"\365\001\n\024AutomatonDescription"
    "\022%\n\nidentifier\030\001 \002(\0132\021.tesla.Identifier\022"
    "4\n\007context\030\002 \002(\0162#.tesla.AutomatonDescri"
    "ption.Context\022%\n\nexpression\030\003 \002(\0132\021.tesl"
    "a.Expression\022!\n\010argument\030\005 \003(\0132\017.tesla.A"
    "rgument\022\016\n\006source\030\006 \001(\t\"&\n\007Context\022\n\n\006Gl"
    "obal\020\001\022\017\n\013ThreadLocal\020\002\"=\n\nIdentifier\022\014\n"
    "\004name\030\001 \001(\t\022!\n\010location\030\002 \001(\0132\017.tesla.Lo"
    "cation\";\n\010Location\022\020\n\010filename\030\001 \002(\t\022\014\n\004"
    "line\030\002 \002(\005\022\017\n\007counter\030\003 \002(\005\"\244\003\n\nExpressi"
    "on\022$\n\004type\030\001 \002(\0162\026.tesla.Expression.Type"
    "\022\'\n\013booleanExpr\030\002 \001(\0132\022.tesla.BooleanExp"
    "r\022!\n\010sequence\030\003 \001(\0132\017.tesla.Sequence\022(\n\n"
    "assertSite\030\004 \001(\0132\024.tesla.AssertionSite\022&"
    "\n\010function\030\005 \001(\0132\024.tesla.FunctionEvent\022+"
    "\n\013fieldAssign\030\006 \001(\0132\026.tesla.FieldAssignm"
    "ent\022\'\n\014subAutomaton\030\007 \001(\0132\021.tesla.Identi"
    "fier\"|\n\004Type\022\020\n\014BOOLEAN_EXPR\020\001\022\014\n\010SEQUEN"
    "CE\020\002\022\r\n\tNULL_EXPR\020\003\022\022\n\016ASSERTION_SITE\020\004\022"
    "\014\n\010FUNCTION\020\005\022\020\n\014FIELD_ASSIGN\020\006\022\021\n\rSUB_A"
    "UTOMATON\020\007\"\225\001\n\013BooleanExpr\022/\n\toperation\030"
    "\001 \002(\0162\034.tesla.BooleanExpr.Operation\022%\n\ne"
    "xpression\030\002 \003(\0132\021.tesla.Expression\".\n\tOp"
    "eration\022\n\n\006BE_And\020\001\022\t\n\005BE_Or\020\002\022\n\n\006BE_Xor"
    "\020\003\"Y\n\010Sequence\022%\n\nexpression\030\001 \003(\0132\021.tes"
    "la.Expression\022\022\n\007minReps\030\002 \001(\005:\0011\022\022\n\007max"
    "Reps\030\003 \001(\005:\0011\"2\n\rAssertionSite\022!\n\010locati"
    "on\030\001 \002(\0132\017.tesla.Location\"\376\003\n\rFunctionEv"
    "ent\022$\n\010function\030\001 \002(\0132\022.tesla.FunctionRe"
    "f\0221\n\tdirection\030\002 \001(\0162\036.tesla.FunctionEve"
    "nt.Direction\0221\n\007context\030\003 \001(\0162 .tesla.Fu"
    "nctionEvent.CallContext\022!\n\010argument\030\004 \003("
    "\0132\017.tesla.Argument\022,\n\023expectedReturnValu"
    "e\030\005 \001(\0132\017.tesla.Argument\022\024\n\006strict\030\006 \001(\010"
    ":\004true\0222\n\004kind\030\007 \001(\0162\035.tesla.FunctionEve"
    "nt.CallKind:\005CCall\022!\n\010receiver\030\010 \001(\0132\017.t"
    "esla.Argument\" \n\tDirection\022\t\n\005Entry\020\001\022\010\n"
    "\004Exit\020\002\"%\n\013CallContext\022\n\n\006Caller\020\001\022\n\n\006Ca"
    "llee\020\002\"Z\n\010CallKind\022\t\n\005CCall\020\001\022\027\n\023ObjCIns"
    "tanceMessage\020\002\022\024\n\020ObjCClassMessage\020\003\022\024\n\020"
    "ObjCSuperMessage\020\004\"\033\n\013FunctionRef\022\014\n\004nam"
    "e\030\001 \002(\t\"\337\001\n\017FieldAssignment\022!\n\005field\030\010 \002"
    "(\0132\022.tesla.StructField\0224\n\toperation\030\004 \002("
    "\0162!.tesla.FieldAssignment.AssignType\022\036\n\005"
    "value\030\005 \002(\0132\017.tesla.Argument\022\024\n\006strict\030\007"
    " \001(\010:\004true\"=\n\nAssignType\022\020\n\014SimpleAssign"
    "\020\001\022\r\n\tPlusEqual\020\002\022\016\n\nMinusEqual\020\003\"W\n\013Str"
    "uctField\022\014\n\004type\030\001 \002(\t\022\035\n\004base\030\002 \002(\0132\017.t"
    "esla.Argument\022\014\n\004name\030\003 \002(\t\022\r\n\005index\030\004 \002"
    "(\005\"\344\002\n\010Argument\022\"\n\004type\030\001 \002(\0162\024.tesla.Ar"
    "gument.Type\022\r\n\005index\030\002 \001(\005\022\014\n\004name\030\003 \001(\t"
    "\022\023\n\004free\030\t \001(\010:\005false\022\r\n\005value\030\005 \001(\003\0227\n\r"
    "constantMatch\030\006 \001(\0162\031.tesla.Argument.Mat"
    "chType:\005Exact\022$\n\013indirection\030\007 \001(\0132\017.tes"
    "la.Argument\022!\n\005field\030\010 \001(\0132\022.tesla.Struc"
    "tField\"D\n\004Type\022\014\n\010Constant\020\001\022\014\n\010Variable"
    "\020\002\022\007\n\003Any\020\003\022\014\n\010Indirect\020\004\022\t\n\005Field\020\005\"+\n\t"
    "MatchType\022\t\n\005Exact\020\001\022\t\n\005Flags\020\002\022\010\n\004Mask\020"
    "\003", 2561);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "tesla.proto", &protobuf_RegisterTypes);
  ManifestFile::default_instance_ = new ManifestFile();
  Usage::default_instance_ = new Usage();
  AutomatonDescription::default_instance_ = new AutomatonDescription();
  Identifier::default_instance_ = new Identifier();
  Location::default_instance_ = new Location();
  Expression::default_instance_ = new Expression();
  BooleanExpr::default_instance_ = new BooleanExpr();
  Sequence::default_instance_ = new Sequence();
  AssertionSite::default_instance_ = new AssertionSite();
  FunctionEvent::default_instance_ = new FunctionEvent();
  FunctionRef::default_instance_ = new FunctionRef();
  FieldAssignment::default_instance_ = new FieldAssignment();
  StructField::default_instance_ = new StructField();
  Argument::default_instance_ = new Argument();
  ManifestFile::default_instance_->InitAsDefaultInstance();
  Usage::default_instance_->InitAsDefaultInstance();
  AutomatonDescription::default_instance_->InitAsDefaultInstance();
  Identifier::default_instance_->InitAsDefaultInstance();
  Location::default_instance_->InitAsDefaultInstance();
  Expression::default_instance_->InitAsDefaultInstance();
  BooleanExpr::default_instance_->InitAsDefaultInstance();
  Sequence::default_instance_->InitAsDefaultInstance();
  AssertionSite::default_instance_->InitAsDefaultInstance();
  FunctionEvent::default_instance_->InitAsDefaultInstance();
  FunctionRef::default_instance_->InitAsDefaultInstance();
  FieldAssignment::default_instance_->InitAsDefaultInstance();
  StructField::default_instance_->InitAsDefaultInstance();
  Argument::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_tesla_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_tesla_2eproto {
  StaticDescriptorInitializer_tesla_2eproto() {
    protobuf_AddDesc_tesla_2eproto();
  }
} static_descriptor_initializer_tesla_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int ManifestFile::kAutomatonFieldNumber;
const int ManifestFile::kRootFieldNumber;
#endif  // !_MSC_VER

ManifestFile::ManifestFile()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:tesla.ManifestFile)
}

void ManifestFile::InitAsDefaultInstance() {
}

ManifestFile::ManifestFile(const ManifestFile& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:tesla.ManifestFile)
}

void ManifestFile::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ManifestFile::~ManifestFile() {
  // @@protoc_insertion_point(destructor:tesla.ManifestFile)
  SharedDtor();
}

void ManifestFile::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ManifestFile::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ManifestFile::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ManifestFile_descriptor_;
}

const ManifestFile& ManifestFile::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tesla_2eproto();
  return *default_instance_;
}

ManifestFile* ManifestFile::default_instance_ = NULL;

ManifestFile* ManifestFile::New() const {
  return new ManifestFile;
}

void ManifestFile::Clear() {
  automaton_.Clear();
  root_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ManifestFile::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tesla.ManifestFile)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .tesla.AutomatonDescription automaton = 1;
      case 1: {
        if (tag == 10) {
         parse_automaton:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_automaton()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_automaton;
        if (input->ExpectTag(18)) goto parse_root;
        break;
      }

      // repeated .tesla.Usage root = 2;
      case 2: {
        if (tag == 18) {
         parse_root:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_root()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_root;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tesla.ManifestFile)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tesla.ManifestFile)
  return false;
#undef DO_
}

void ManifestFile::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tesla.ManifestFile)
  // repeated .tesla.AutomatonDescription automaton = 1;
  for (int i = 0; i < this->automaton_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->automaton(i), output);
  }

  // repeated .tesla.Usage root = 2;
  for (int i = 0; i < this->root_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->root(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tesla.ManifestFile)
}

::google::protobuf::uint8* ManifestFile::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:tesla.ManifestFile)
  // repeated .tesla.AutomatonDescription automaton = 1;
  for (int i = 0; i < this->automaton_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->automaton(i), target);
  }

  // repeated .tesla.Usage root = 2;
  for (int i = 0; i < this->root_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->root(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tesla.ManifestFile)
  return target;
}

int ManifestFile::ByteSize() const {
  int total_size = 0;

  // repeated .tesla.AutomatonDescription automaton = 1;
  total_size += 1 * this->automaton_size();
  for (int i = 0; i < this->automaton_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->automaton(i));
  }

  // repeated .tesla.Usage root = 2;
  total_size += 1 * this->root_size();
  for (int i = 0; i < this->root_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->root(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ManifestFile::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ManifestFile* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ManifestFile*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ManifestFile::MergeFrom(const ManifestFile& from) {
  GOOGLE_CHECK_NE(&from, this);
  automaton_.MergeFrom(from.automaton_);
  root_.MergeFrom(from.root_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ManifestFile::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ManifestFile::CopyFrom(const ManifestFile& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ManifestFile::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->automaton())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->root())) return false;
  return true;
}

void ManifestFile::Swap(ManifestFile* other) {
  if (other != this) {
    automaton_.Swap(&other->automaton_);
    root_.Swap(&other->root_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ManifestFile::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ManifestFile_descriptor_;
  metadata.reflection = ManifestFile_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Usage::kIdentifierFieldNumber;
const int Usage::kBeginningFieldNumber;
const int Usage::kEndFieldNumber;
const int Usage::kDeletedFieldNumber;
#endif  // !_MSC_VER

Usage::Usage()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:tesla.Usage)
}

void Usage::InitAsDefaultInstance() {
  identifier_ = const_cast< ::tesla::Identifier*>(&::tesla::Identifier::default_instance());
  beginning_ = const_cast< ::tesla::Expression*>(&::tesla::Expression::default_instance());
  end_ = const_cast< ::tesla::Expression*>(&::tesla::Expression::default_instance());
}

Usage::Usage(const Usage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:tesla.Usage)
}

void Usage::SharedCtor() {
  _cached_size_ = 0;
  identifier_ = NULL;
  beginning_ = NULL;
  end_ = NULL;
  deleted_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Usage::~Usage() {
  // @@protoc_insertion_point(destructor:tesla.Usage)
  SharedDtor();
}

void Usage::SharedDtor() {
  if (this != default_instance_) {
    delete identifier_;
    delete beginning_;
    delete end_;
  }
}

void Usage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Usage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Usage_descriptor_;
}

const Usage& Usage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tesla_2eproto();
  return *default_instance_;
}

Usage* Usage::default_instance_ = NULL;

Usage* Usage::New() const {
  return new Usage;
}

void Usage::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    if (has_identifier()) {
      if (identifier_ != NULL) identifier_->::tesla::Identifier::Clear();
    }
    if (has_beginning()) {
      if (beginning_ != NULL) beginning_->::tesla::Expression::Clear();
    }
    if (has_end()) {
      if (end_ != NULL) end_->::tesla::Expression::Clear();
    }
    deleted_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Usage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tesla.Usage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .tesla.Identifier identifier = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_identifier()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_beginning;
        break;
      }

      // optional .tesla.Expression beginning = 2;
      case 2: {
        if (tag == 18) {
         parse_beginning:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_beginning()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_end;
        break;
      }

      // optional .tesla.Expression end = 3;
      case 3: {
        if (tag == 26) {
         parse_end:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_end()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_deleted;
        break;
      }

      // optional bool deleted = 4 [default = false];
      case 4: {
        if (tag == 32) {
         parse_deleted:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &deleted_)));
          set_has_deleted();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tesla.Usage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tesla.Usage)
  return false;
#undef DO_
}

void Usage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tesla.Usage)
  // required .tesla.Identifier identifier = 1;
  if (has_identifier()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->identifier(), output);
  }

  // optional .tesla.Expression beginning = 2;
  if (has_beginning()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->beginning(), output);
  }

  // optional .tesla.Expression end = 3;
  if (has_end()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->end(), output);
  }

  // optional bool deleted = 4 [default = false];
  if (has_deleted()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->deleted(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tesla.Usage)
}

::google::protobuf::uint8* Usage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:tesla.Usage)
  // required .tesla.Identifier identifier = 1;
  if (has_identifier()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->identifier(), target);
  }

  // optional .tesla.Expression beginning = 2;
  if (has_beginning()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->beginning(), target);
  }

  // optional .tesla.Expression end = 3;
  if (has_end()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->end(), target);
  }

  // optional bool deleted = 4 [default = false];
  if (has_deleted()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->deleted(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tesla.Usage)
  return target;
}

int Usage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .tesla.Identifier identifier = 1;
    if (has_identifier()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->identifier());
    }

    // optional .tesla.Expression beginning = 2;
    if (has_beginning()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->beginning());
    }

    // optional .tesla.Expression end = 3;
    if (has_end()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->end());
    }

    // optional bool deleted = 4 [default = false];
    if (has_deleted()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Usage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Usage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Usage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Usage::MergeFrom(const Usage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_identifier()) {
      mutable_identifier()->::tesla::Identifier::MergeFrom(from.identifier());
    }
    if (from.has_beginning()) {
      mutable_beginning()->::tesla::Expression::MergeFrom(from.beginning());
    }
    if (from.has_end()) {
      mutable_end()->::tesla::Expression::MergeFrom(from.end());
    }
    if (from.has_deleted()) {
      set_deleted(from.deleted());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Usage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Usage::CopyFrom(const Usage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Usage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_identifier()) {
    if (!this->identifier().IsInitialized()) return false;
  }
  if (has_beginning()) {
    if (!this->beginning().IsInitialized()) return false;
  }
  if (has_end()) {
    if (!this->end().IsInitialized()) return false;
  }
  return true;
}

void Usage::Swap(Usage* other) {
  if (other != this) {
    std::swap(identifier_, other->identifier_);
    std::swap(beginning_, other->beginning_);
    std::swap(end_, other->end_);
    std::swap(deleted_, other->deleted_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Usage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Usage_descriptor_;
  metadata.reflection = Usage_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* AutomatonDescription_Context_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AutomatonDescription_Context_descriptor_;
}
bool AutomatonDescription_Context_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const AutomatonDescription_Context AutomatonDescription::Global;
const AutomatonDescription_Context AutomatonDescription::ThreadLocal;
const AutomatonDescription_Context AutomatonDescription::Context_MIN;
const AutomatonDescription_Context AutomatonDescription::Context_MAX;
const int AutomatonDescription::Context_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int AutomatonDescription::kIdentifierFieldNumber;
const int AutomatonDescription::kContextFieldNumber;
const int AutomatonDescription::kExpressionFieldNumber;
const int AutomatonDescription::kArgumentFieldNumber;
const int AutomatonDescription::kSourceFieldNumber;
#endif  // !_MSC_VER

AutomatonDescription::AutomatonDescription()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:tesla.AutomatonDescription)
}

void AutomatonDescription::InitAsDefaultInstance() {
  identifier_ = const_cast< ::tesla::Identifier*>(&::tesla::Identifier::default_instance());
  expression_ = const_cast< ::tesla::Expression*>(&::tesla::Expression::default_instance());
}

AutomatonDescription::AutomatonDescription(const AutomatonDescription& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:tesla.AutomatonDescription)
}

void AutomatonDescription::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  identifier_ = NULL;
  context_ = 1;
  expression_ = NULL;
  source_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AutomatonDescription::~AutomatonDescription() {
  // @@protoc_insertion_point(destructor:tesla.AutomatonDescription)
  SharedDtor();
}

void AutomatonDescription::SharedDtor() {
  if (source_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete source_;
  }
  if (this != default_instance_) {
    delete identifier_;
    delete expression_;
  }
}

void AutomatonDescription::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AutomatonDescription::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AutomatonDescription_descriptor_;
}

const AutomatonDescription& AutomatonDescription::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tesla_2eproto();
  return *default_instance_;
}

AutomatonDescription* AutomatonDescription::default_instance_ = NULL;

AutomatonDescription* AutomatonDescription::New() const {
  return new AutomatonDescription;
}

void AutomatonDescription::Clear() {
  if (_has_bits_[0 / 32] & 23) {
    if (has_identifier()) {
      if (identifier_ != NULL) identifier_->::tesla::Identifier::Clear();
    }
    context_ = 1;
    if (has_expression()) {
      if (expression_ != NULL) expression_->::tesla::Expression::Clear();
    }
    if (has_source()) {
      if (source_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        source_->clear();
      }
    }
  }
  argument_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AutomatonDescription::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tesla.AutomatonDescription)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .tesla.Identifier identifier = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_identifier()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_context;
        break;
      }

      // required .tesla.AutomatonDescription.Context context = 2;
      case 2: {
        if (tag == 16) {
         parse_context:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::tesla::AutomatonDescription_Context_IsValid(value)) {
            set_context(static_cast< ::tesla::AutomatonDescription_Context >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_expression;
        break;
      }

      // required .tesla.Expression expression = 3;
      case 3: {
        if (tag == 26) {
         parse_expression:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_expression()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_argument;
        break;
      }

      // repeated .tesla.Argument argument = 5;
      case 5: {
        if (tag == 42) {
         parse_argument:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_argument()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_argument;
        if (input->ExpectTag(50)) goto parse_source;
        break;
      }

      // optional string source = 6;
      case 6: {
        if (tag == 50) {
         parse_source:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_source()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->source().data(), this->source().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "source");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tesla.AutomatonDescription)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tesla.AutomatonDescription)
  return false;
#undef DO_
}

void AutomatonDescription::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tesla.AutomatonDescription)
  // required .tesla.Identifier identifier = 1;
  if (has_identifier()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->identifier(), output);
  }

  // required .tesla.AutomatonDescription.Context context = 2;
  if (has_context()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->context(), output);
  }

  // required .tesla.Expression expression = 3;
  if (has_expression()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->expression(), output);
  }

  // repeated .tesla.Argument argument = 5;
  for (int i = 0; i < this->argument_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->argument(i), output);
  }

  // optional string source = 6;
  if (has_source()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->source().data(), this->source().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "source");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->source(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tesla.AutomatonDescription)
}

::google::protobuf::uint8* AutomatonDescription::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:tesla.AutomatonDescription)
  // required .tesla.Identifier identifier = 1;
  if (has_identifier()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->identifier(), target);
  }

  // required .tesla.AutomatonDescription.Context context = 2;
  if (has_context()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->context(), target);
  }

  // required .tesla.Expression expression = 3;
  if (has_expression()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->expression(), target);
  }

  // repeated .tesla.Argument argument = 5;
  for (int i = 0; i < this->argument_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->argument(i), target);
  }

  // optional string source = 6;
  if (has_source()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->source().data(), this->source().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "source");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->source(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tesla.AutomatonDescription)
  return target;
}

int AutomatonDescription::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .tesla.Identifier identifier = 1;
    if (has_identifier()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->identifier());
    }

    // required .tesla.AutomatonDescription.Context context = 2;
    if (has_context()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->context());
    }

    // required .tesla.Expression expression = 3;
    if (has_expression()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->expression());
    }

    // optional string source = 6;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->source());
    }

  }
  // repeated .tesla.Argument argument = 5;
  total_size += 1 * this->argument_size();
  for (int i = 0; i < this->argument_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->argument(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AutomatonDescription::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AutomatonDescription* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AutomatonDescription*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AutomatonDescription::MergeFrom(const AutomatonDescription& from) {
  GOOGLE_CHECK_NE(&from, this);
  argument_.MergeFrom(from.argument_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_identifier()) {
      mutable_identifier()->::tesla::Identifier::MergeFrom(from.identifier());
    }
    if (from.has_context()) {
      set_context(from.context());
    }
    if (from.has_expression()) {
      mutable_expression()->::tesla::Expression::MergeFrom(from.expression());
    }
    if (from.has_source()) {
      set_source(from.source());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AutomatonDescription::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AutomatonDescription::CopyFrom(const AutomatonDescription& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AutomatonDescription::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_identifier()) {
    if (!this->identifier().IsInitialized()) return false;
  }
  if (has_expression()) {
    if (!this->expression().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->argument())) return false;
  return true;
}

void AutomatonDescription::Swap(AutomatonDescription* other) {
  if (other != this) {
    std::swap(identifier_, other->identifier_);
    std::swap(context_, other->context_);
    std::swap(expression_, other->expression_);
    argument_.Swap(&other->argument_);
    std::swap(source_, other->source_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AutomatonDescription::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AutomatonDescription_descriptor_;
  metadata.reflection = AutomatonDescription_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Identifier::kNameFieldNumber;
const int Identifier::kLocationFieldNumber;
#endif  // !_MSC_VER

Identifier::Identifier()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:tesla.Identifier)
}

void Identifier::InitAsDefaultInstance() {
  location_ = const_cast< ::tesla::Location*>(&::tesla::Location::default_instance());
}

Identifier::Identifier(const Identifier& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:tesla.Identifier)
}

void Identifier::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  location_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Identifier::~Identifier() {
  // @@protoc_insertion_point(destructor:tesla.Identifier)
  SharedDtor();
}

void Identifier::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (this != default_instance_) {
    delete location_;
  }
}

void Identifier::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Identifier::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Identifier_descriptor_;
}

const Identifier& Identifier::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tesla_2eproto();
  return *default_instance_;
}

Identifier* Identifier::default_instance_ = NULL;

Identifier* Identifier::New() const {
  return new Identifier;
}

void Identifier::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    if (has_location()) {
      if (location_ != NULL) location_->::tesla::Location::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Identifier::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tesla.Identifier)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_location;
        break;
      }

      // optional .tesla.Location location = 2;
      case 2: {
        if (tag == 18) {
         parse_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_location()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tesla.Identifier)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tesla.Identifier)
  return false;
#undef DO_
}

void Identifier::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tesla.Identifier)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional .tesla.Location location = 2;
  if (has_location()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->location(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tesla.Identifier)
}

::google::protobuf::uint8* Identifier::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:tesla.Identifier)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional .tesla.Location location = 2;
  if (has_location()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->location(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tesla.Identifier)
  return target;
}

int Identifier::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional .tesla.Location location = 2;
    if (has_location()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->location());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Identifier::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Identifier* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Identifier*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Identifier::MergeFrom(const Identifier& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_location()) {
      mutable_location()->::tesla::Location::MergeFrom(from.location());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Identifier::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Identifier::CopyFrom(const Identifier& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Identifier::IsInitialized() const {

  if (has_location()) {
    if (!this->location().IsInitialized()) return false;
  }
  return true;
}

void Identifier::Swap(Identifier* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(location_, other->location_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Identifier::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Identifier_descriptor_;
  metadata.reflection = Identifier_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Location::kFilenameFieldNumber;
const int Location::kLineFieldNumber;
const int Location::kCounterFieldNumber;
#endif  // !_MSC_VER

Location::Location()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:tesla.Location)
}

void Location::InitAsDefaultInstance() {
}

Location::Location(const Location& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:tesla.Location)
}

void Location::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  line_ = 0;
  counter_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Location::~Location() {
  // @@protoc_insertion_point(destructor:tesla.Location)
  SharedDtor();
}

void Location::SharedDtor() {
  if (filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filename_;
  }
  if (this != default_instance_) {
  }
}

void Location::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Location::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Location_descriptor_;
}

const Location& Location::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tesla_2eproto();
  return *default_instance_;
}

Location* Location::default_instance_ = NULL;

Location* Location::New() const {
  return new Location;
}

void Location::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Location*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(line_, counter_);
    if (has_filename()) {
      if (filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        filename_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Location::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tesla.Location)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string filename = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_filename()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->filename().data(), this->filename().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "filename");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_line;
        break;
      }

      // required int32 line = 2;
      case 2: {
        if (tag == 16) {
         parse_line:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &line_)));
          set_has_line();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_counter;
        break;
      }

      // required int32 counter = 3;
      case 3: {
        if (tag == 24) {
         parse_counter:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &counter_)));
          set_has_counter();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tesla.Location)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tesla.Location)
  return false;
#undef DO_
}

void Location::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tesla.Location)
  // required string filename = 1;
  if (has_filename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->filename().data(), this->filename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "filename");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->filename(), output);
  }

  // required int32 line = 2;
  if (has_line()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->line(), output);
  }

  // required int32 counter = 3;
  if (has_counter()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->counter(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tesla.Location)
}

::google::protobuf::uint8* Location::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:tesla.Location)
  // required string filename = 1;
  if (has_filename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->filename().data(), this->filename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "filename");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->filename(), target);
  }

  // required int32 line = 2;
  if (has_line()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->line(), target);
  }

  // required int32 counter = 3;
  if (has_counter()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->counter(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tesla.Location)
  return target;
}

int Location::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string filename = 1;
    if (has_filename()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->filename());
    }

    // required int32 line = 2;
    if (has_line()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->line());
    }

    // required int32 counter = 3;
    if (has_counter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->counter());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Location::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Location* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Location*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Location::MergeFrom(const Location& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_filename()) {
      set_filename(from.filename());
    }
    if (from.has_line()) {
      set_line(from.line());
    }
    if (from.has_counter()) {
      set_counter(from.counter());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Location::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Location::CopyFrom(const Location& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Location::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void Location::Swap(Location* other) {
  if (other != this) {
    std::swap(filename_, other->filename_);
    std::swap(line_, other->line_);
    std::swap(counter_, other->counter_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Location::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Location_descriptor_;
  metadata.reflection = Location_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Expression_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Expression_Type_descriptor_;
}
bool Expression_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Expression_Type Expression::BOOLEAN_EXPR;
const Expression_Type Expression::SEQUENCE;
const Expression_Type Expression::NULL_EXPR;
const Expression_Type Expression::ASSERTION_SITE;
const Expression_Type Expression::FUNCTION;
const Expression_Type Expression::FIELD_ASSIGN;
const Expression_Type Expression::SUB_AUTOMATON;
const Expression_Type Expression::Type_MIN;
const Expression_Type Expression::Type_MAX;
const int Expression::Type_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Expression::kTypeFieldNumber;
const int Expression::kBooleanExprFieldNumber;
const int Expression::kSequenceFieldNumber;
const int Expression::kAssertSiteFieldNumber;
const int Expression::kFunctionFieldNumber;
const int Expression::kFieldAssignFieldNumber;
const int Expression::kSubAutomatonFieldNumber;
#endif  // !_MSC_VER

Expression::Expression()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:tesla.Expression)
}

void Expression::InitAsDefaultInstance() {
  booleanexpr_ = const_cast< ::tesla::BooleanExpr*>(&::tesla::BooleanExpr::default_instance());
  sequence_ = const_cast< ::tesla::Sequence*>(&::tesla::Sequence::default_instance());
  assertsite_ = const_cast< ::tesla::AssertionSite*>(&::tesla::AssertionSite::default_instance());
  function_ = const_cast< ::tesla::FunctionEvent*>(&::tesla::FunctionEvent::default_instance());
  fieldassign_ = const_cast< ::tesla::FieldAssignment*>(&::tesla::FieldAssignment::default_instance());
  subautomaton_ = const_cast< ::tesla::Identifier*>(&::tesla::Identifier::default_instance());
}

Expression::Expression(const Expression& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:tesla.Expression)
}

void Expression::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  booleanexpr_ = NULL;
  sequence_ = NULL;
  assertsite_ = NULL;
  function_ = NULL;
  fieldassign_ = NULL;
  subautomaton_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Expression::~Expression() {
  // @@protoc_insertion_point(destructor:tesla.Expression)
  SharedDtor();
}

void Expression::SharedDtor() {
  if (this != default_instance_) {
    delete booleanexpr_;
    delete sequence_;
    delete assertsite_;
    delete function_;
    delete fieldassign_;
    delete subautomaton_;
  }
}

void Expression::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Expression::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Expression_descriptor_;
}

const Expression& Expression::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tesla_2eproto();
  return *default_instance_;
}

Expression* Expression::default_instance_ = NULL;

Expression* Expression::New() const {
  return new Expression;
}

void Expression::Clear() {
  if (_has_bits_[0 / 32] & 127) {
    type_ = 1;
    if (has_booleanexpr()) {
      if (booleanexpr_ != NULL) booleanexpr_->::tesla::BooleanExpr::Clear();
    }
    if (has_sequence()) {
      if (sequence_ != NULL) sequence_->::tesla::Sequence::Clear();
    }
    if (has_assertsite()) {
      if (assertsite_ != NULL) assertsite_->::tesla::AssertionSite::Clear();
    }
    if (has_function()) {
      if (function_ != NULL) function_->::tesla::FunctionEvent::Clear();
    }
    if (has_fieldassign()) {
      if (fieldassign_ != NULL) fieldassign_->::tesla::FieldAssignment::Clear();
    }
    if (has_subautomaton()) {
      if (subautomaton_ != NULL) subautomaton_->::tesla::Identifier::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Expression::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tesla.Expression)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .tesla.Expression.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::tesla::Expression_Type_IsValid(value)) {
            set_type(static_cast< ::tesla::Expression_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_booleanExpr;
        break;
      }

      // optional .tesla.BooleanExpr booleanExpr = 2;
      case 2: {
        if (tag == 18) {
         parse_booleanExpr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_booleanexpr()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_sequence;
        break;
      }

      // optional .tesla.Sequence sequence = 3;
      case 3: {
        if (tag == 26) {
         parse_sequence:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sequence()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_assertSite;
        break;
      }

      // optional .tesla.AssertionSite assertSite = 4;
      case 4: {
        if (tag == 34) {
         parse_assertSite:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_assertsite()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_function;
        break;
      }

      // optional .tesla.FunctionEvent function = 5;
      case 5: {
        if (tag == 42) {
         parse_function:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_function()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_fieldAssign;
        break;
      }

      // optional .tesla.FieldAssignment fieldAssign = 6;
      case 6: {
        if (tag == 50) {
         parse_fieldAssign:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_fieldassign()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_subAutomaton;
        break;
      }

      // optional .tesla.Identifier subAutomaton = 7;
      case 7: {
        if (tag == 58) {
         parse_subAutomaton:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_subautomaton()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tesla.Expression)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tesla.Expression)
  return false;
#undef DO_
}

void Expression::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tesla.Expression)
  // required .tesla.Expression.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .tesla.BooleanExpr booleanExpr = 2;
  if (has_booleanexpr()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->booleanexpr(), output);
  }

  // optional .tesla.Sequence sequence = 3;
  if (has_sequence()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->sequence(), output);
  }

  // optional .tesla.AssertionSite assertSite = 4;
  if (has_assertsite()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->assertsite(), output);
  }

  // optional .tesla.FunctionEvent function = 5;
  if (has_function()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->function(), output);
  }

  // optional .tesla.FieldAssignment fieldAssign = 6;
  if (has_fieldassign()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->fieldassign(), output);
  }

  // optional .tesla.Identifier subAutomaton = 7;
  if (has_subautomaton()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->subautomaton(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tesla.Expression)
}

::google::protobuf::uint8* Expression::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:tesla.Expression)
  // required .tesla.Expression.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .tesla.BooleanExpr booleanExpr = 2;
  if (has_booleanexpr()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->booleanexpr(), target);
  }

  // optional .tesla.Sequence sequence = 3;
  if (has_sequence()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->sequence(), target);
  }

  // optional .tesla.AssertionSite assertSite = 4;
  if (has_assertsite()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->assertsite(), target);
  }

  // optional .tesla.FunctionEvent function = 5;
  if (has_function()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->function(), target);
  }

  // optional .tesla.FieldAssignment fieldAssign = 6;
  if (has_fieldassign()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->fieldassign(), target);
  }

  // optional .tesla.Identifier subAutomaton = 7;
  if (has_subautomaton()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->subautomaton(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tesla.Expression)
  return target;
}

int Expression::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .tesla.Expression.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .tesla.BooleanExpr booleanExpr = 2;
    if (has_booleanexpr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->booleanexpr());
    }

    // optional .tesla.Sequence sequence = 3;
    if (has_sequence()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sequence());
    }

    // optional .tesla.AssertionSite assertSite = 4;
    if (has_assertsite()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->assertsite());
    }

    // optional .tesla.FunctionEvent function = 5;
    if (has_function()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->function());
    }

    // optional .tesla.FieldAssignment fieldAssign = 6;
    if (has_fieldassign()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->fieldassign());
    }

    // optional .tesla.Identifier subAutomaton = 7;
    if (has_subautomaton()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->subautomaton());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Expression::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Expression* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Expression*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Expression::MergeFrom(const Expression& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_booleanexpr()) {
      mutable_booleanexpr()->::tesla::BooleanExpr::MergeFrom(from.booleanexpr());
    }
    if (from.has_sequence()) {
      mutable_sequence()->::tesla::Sequence::MergeFrom(from.sequence());
    }
    if (from.has_assertsite()) {
      mutable_assertsite()->::tesla::AssertionSite::MergeFrom(from.assertsite());
    }
    if (from.has_function()) {
      mutable_function()->::tesla::FunctionEvent::MergeFrom(from.function());
    }
    if (from.has_fieldassign()) {
      mutable_fieldassign()->::tesla::FieldAssignment::MergeFrom(from.fieldassign());
    }
    if (from.has_subautomaton()) {
      mutable_subautomaton()->::tesla::Identifier::MergeFrom(from.subautomaton());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Expression::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Expression::CopyFrom(const Expression& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Expression::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_booleanexpr()) {
    if (!this->booleanexpr().IsInitialized()) return false;
  }
  if (has_sequence()) {
    if (!this->sequence().IsInitialized()) return false;
  }
  if (has_assertsite()) {
    if (!this->assertsite().IsInitialized()) return false;
  }
  if (has_function()) {
    if (!this->function().IsInitialized()) return false;
  }
  if (has_fieldassign()) {
    if (!this->fieldassign().IsInitialized()) return false;
  }
  if (has_subautomaton()) {
    if (!this->subautomaton().IsInitialized()) return false;
  }
  return true;
}

void Expression::Swap(Expression* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(booleanexpr_, other->booleanexpr_);
    std::swap(sequence_, other->sequence_);
    std::swap(assertsite_, other->assertsite_);
    std::swap(function_, other->function_);
    std::swap(fieldassign_, other->fieldassign_);
    std::swap(subautomaton_, other->subautomaton_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Expression::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Expression_descriptor_;
  metadata.reflection = Expression_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* BooleanExpr_Operation_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BooleanExpr_Operation_descriptor_;
}
bool BooleanExpr_Operation_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const BooleanExpr_Operation BooleanExpr::BE_And;
const BooleanExpr_Operation BooleanExpr::BE_Or;
const BooleanExpr_Operation BooleanExpr::BE_Xor;
const BooleanExpr_Operation BooleanExpr::Operation_MIN;
const BooleanExpr_Operation BooleanExpr::Operation_MAX;
const int BooleanExpr::Operation_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int BooleanExpr::kOperationFieldNumber;
const int BooleanExpr::kExpressionFieldNumber;
#endif  // !_MSC_VER

BooleanExpr::BooleanExpr()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:tesla.BooleanExpr)
}

void BooleanExpr::InitAsDefaultInstance() {
}

BooleanExpr::BooleanExpr(const BooleanExpr& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:tesla.BooleanExpr)
}

void BooleanExpr::SharedCtor() {
  _cached_size_ = 0;
  operation_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BooleanExpr::~BooleanExpr() {
  // @@protoc_insertion_point(destructor:tesla.BooleanExpr)
  SharedDtor();
}

void BooleanExpr::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BooleanExpr::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BooleanExpr::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BooleanExpr_descriptor_;
}

const BooleanExpr& BooleanExpr::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tesla_2eproto();
  return *default_instance_;
}

BooleanExpr* BooleanExpr::default_instance_ = NULL;

BooleanExpr* BooleanExpr::New() const {
  return new BooleanExpr;
}

void BooleanExpr::Clear() {
  operation_ = 1;
  expression_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BooleanExpr::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tesla.BooleanExpr)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .tesla.BooleanExpr.Operation operation = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::tesla::BooleanExpr_Operation_IsValid(value)) {
            set_operation(static_cast< ::tesla::BooleanExpr_Operation >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_expression;
        break;
      }

      // repeated .tesla.Expression expression = 2;
      case 2: {
        if (tag == 18) {
         parse_expression:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_expression()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_expression;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tesla.BooleanExpr)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tesla.BooleanExpr)
  return false;
#undef DO_
}

void BooleanExpr::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tesla.BooleanExpr)
  // required .tesla.BooleanExpr.Operation operation = 1;
  if (has_operation()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->operation(), output);
  }

  // repeated .tesla.Expression expression = 2;
  for (int i = 0; i < this->expression_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->expression(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tesla.BooleanExpr)
}

::google::protobuf::uint8* BooleanExpr::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:tesla.BooleanExpr)
  // required .tesla.BooleanExpr.Operation operation = 1;
  if (has_operation()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->operation(), target);
  }

  // repeated .tesla.Expression expression = 2;
  for (int i = 0; i < this->expression_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->expression(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tesla.BooleanExpr)
  return target;
}

int BooleanExpr::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .tesla.BooleanExpr.Operation operation = 1;
    if (has_operation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->operation());
    }

  }
  // repeated .tesla.Expression expression = 2;
  total_size += 1 * this->expression_size();
  for (int i = 0; i < this->expression_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->expression(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BooleanExpr::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BooleanExpr* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BooleanExpr*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BooleanExpr::MergeFrom(const BooleanExpr& from) {
  GOOGLE_CHECK_NE(&from, this);
  expression_.MergeFrom(from.expression_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_operation()) {
      set_operation(from.operation());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BooleanExpr::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BooleanExpr::CopyFrom(const BooleanExpr& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BooleanExpr::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->expression())) return false;
  return true;
}

void BooleanExpr::Swap(BooleanExpr* other) {
  if (other != this) {
    std::swap(operation_, other->operation_);
    expression_.Swap(&other->expression_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BooleanExpr::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BooleanExpr_descriptor_;
  metadata.reflection = BooleanExpr_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Sequence::kExpressionFieldNumber;
const int Sequence::kMinRepsFieldNumber;
const int Sequence::kMaxRepsFieldNumber;
#endif  // !_MSC_VER

Sequence::Sequence()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:tesla.Sequence)
}

void Sequence::InitAsDefaultInstance() {
}

Sequence::Sequence(const Sequence& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:tesla.Sequence)
}

void Sequence::SharedCtor() {
  _cached_size_ = 0;
  minreps_ = 1;
  maxreps_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Sequence::~Sequence() {
  // @@protoc_insertion_point(destructor:tesla.Sequence)
  SharedDtor();
}

void Sequence::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Sequence::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Sequence::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Sequence_descriptor_;
}

const Sequence& Sequence::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tesla_2eproto();
  return *default_instance_;
}

Sequence* Sequence::default_instance_ = NULL;

Sequence* Sequence::New() const {
  return new Sequence;
}

void Sequence::Clear() {
  if (_has_bits_[0 / 32] & 6) {
    minreps_ = 1;
    maxreps_ = 1;
  }
  expression_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Sequence::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tesla.Sequence)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .tesla.Expression expression = 1;
      case 1: {
        if (tag == 10) {
         parse_expression:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_expression()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_expression;
        if (input->ExpectTag(16)) goto parse_minReps;
        break;
      }

      // optional int32 minReps = 2 [default = 1];
      case 2: {
        if (tag == 16) {
         parse_minReps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &minreps_)));
          set_has_minreps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_maxReps;
        break;
      }

      // optional int32 maxReps = 3 [default = 1];
      case 3: {
        if (tag == 24) {
         parse_maxReps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &maxreps_)));
          set_has_maxreps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tesla.Sequence)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tesla.Sequence)
  return false;
#undef DO_
}

void Sequence::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tesla.Sequence)
  // repeated .tesla.Expression expression = 1;
  for (int i = 0; i < this->expression_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->expression(i), output);
  }

  // optional int32 minReps = 2 [default = 1];
  if (has_minreps()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->minreps(), output);
  }

  // optional int32 maxReps = 3 [default = 1];
  if (has_maxreps()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->maxreps(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tesla.Sequence)
}

::google::protobuf::uint8* Sequence::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:tesla.Sequence)
  // repeated .tesla.Expression expression = 1;
  for (int i = 0; i < this->expression_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->expression(i), target);
  }

  // optional int32 minReps = 2 [default = 1];
  if (has_minreps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->minreps(), target);
  }

  // optional int32 maxReps = 3 [default = 1];
  if (has_maxreps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->maxreps(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tesla.Sequence)
  return target;
}

int Sequence::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional int32 minReps = 2 [default = 1];
    if (has_minreps()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->minreps());
    }

    // optional int32 maxReps = 3 [default = 1];
    if (has_maxreps()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->maxreps());
    }

  }
  // repeated .tesla.Expression expression = 1;
  total_size += 1 * this->expression_size();
  for (int i = 0; i < this->expression_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->expression(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Sequence::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Sequence* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Sequence*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Sequence::MergeFrom(const Sequence& from) {
  GOOGLE_CHECK_NE(&from, this);
  expression_.MergeFrom(from.expression_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_minreps()) {
      set_minreps(from.minreps());
    }
    if (from.has_maxreps()) {
      set_maxreps(from.maxreps());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Sequence::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Sequence::CopyFrom(const Sequence& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Sequence::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->expression())) return false;
  return true;
}

void Sequence::Swap(Sequence* other) {
  if (other != this) {
    expression_.Swap(&other->expression_);
    std::swap(minreps_, other->minreps_);
    std::swap(maxreps_, other->maxreps_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Sequence::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Sequence_descriptor_;
  metadata.reflection = Sequence_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AssertionSite::kLocationFieldNumber;
#endif  // !_MSC_VER

AssertionSite::AssertionSite()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:tesla.AssertionSite)
}

void AssertionSite::InitAsDefaultInstance() {
  location_ = const_cast< ::tesla::Location*>(&::tesla::Location::default_instance());
}

AssertionSite::AssertionSite(const AssertionSite& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:tesla.AssertionSite)
}

void AssertionSite::SharedCtor() {
  _cached_size_ = 0;
  location_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AssertionSite::~AssertionSite() {
  // @@protoc_insertion_point(destructor:tesla.AssertionSite)
  SharedDtor();
}

void AssertionSite::SharedDtor() {
  if (this != default_instance_) {
    delete location_;
  }
}

void AssertionSite::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AssertionSite::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AssertionSite_descriptor_;
}

const AssertionSite& AssertionSite::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tesla_2eproto();
  return *default_instance_;
}

AssertionSite* AssertionSite::default_instance_ = NULL;

AssertionSite* AssertionSite::New() const {
  return new AssertionSite;
}

void AssertionSite::Clear() {
  if (has_location()) {
    if (location_ != NULL) location_->::tesla::Location::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AssertionSite::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tesla.AssertionSite)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .tesla.Location location = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_location()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tesla.AssertionSite)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tesla.AssertionSite)
  return false;
#undef DO_
}

void AssertionSite::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tesla.AssertionSite)
  // required .tesla.Location location = 1;
  if (has_location()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->location(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tesla.AssertionSite)
}

::google::protobuf::uint8* AssertionSite::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:tesla.AssertionSite)
  // required .tesla.Location location = 1;
  if (has_location()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->location(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tesla.AssertionSite)
  return target;
}

int AssertionSite::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .tesla.Location location = 1;
    if (has_location()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->location());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AssertionSite::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AssertionSite* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AssertionSite*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AssertionSite::MergeFrom(const AssertionSite& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_location()) {
      mutable_location()->::tesla::Location::MergeFrom(from.location());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AssertionSite::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AssertionSite::CopyFrom(const AssertionSite& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AssertionSite::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_location()) {
    if (!this->location().IsInitialized()) return false;
  }
  return true;
}

void AssertionSite::Swap(AssertionSite* other) {
  if (other != this) {
    std::swap(location_, other->location_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AssertionSite::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AssertionSite_descriptor_;
  metadata.reflection = AssertionSite_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* FunctionEvent_Direction_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FunctionEvent_Direction_descriptor_;
}
bool FunctionEvent_Direction_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const FunctionEvent_Direction FunctionEvent::Entry;
const FunctionEvent_Direction FunctionEvent::Exit;
const FunctionEvent_Direction FunctionEvent::Direction_MIN;
const FunctionEvent_Direction FunctionEvent::Direction_MAX;
const int FunctionEvent::Direction_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* FunctionEvent_CallContext_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FunctionEvent_CallContext_descriptor_;
}
bool FunctionEvent_CallContext_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const FunctionEvent_CallContext FunctionEvent::Caller;
const FunctionEvent_CallContext FunctionEvent::Callee;
const FunctionEvent_CallContext FunctionEvent::CallContext_MIN;
const FunctionEvent_CallContext FunctionEvent::CallContext_MAX;
const int FunctionEvent::CallContext_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* FunctionEvent_CallKind_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FunctionEvent_CallKind_descriptor_;
}
bool FunctionEvent_CallKind_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const FunctionEvent_CallKind FunctionEvent::CCall;
const FunctionEvent_CallKind FunctionEvent::ObjCInstanceMessage;
const FunctionEvent_CallKind FunctionEvent::ObjCClassMessage;
const FunctionEvent_CallKind FunctionEvent::ObjCSuperMessage;
const FunctionEvent_CallKind FunctionEvent::CallKind_MIN;
const FunctionEvent_CallKind FunctionEvent::CallKind_MAX;
const int FunctionEvent::CallKind_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int FunctionEvent::kFunctionFieldNumber;
const int FunctionEvent::kDirectionFieldNumber;
const int FunctionEvent::kContextFieldNumber;
const int FunctionEvent::kArgumentFieldNumber;
const int FunctionEvent::kExpectedReturnValueFieldNumber;
const int FunctionEvent::kStrictFieldNumber;
const int FunctionEvent::kKindFieldNumber;
const int FunctionEvent::kReceiverFieldNumber;
#endif  // !_MSC_VER

FunctionEvent::FunctionEvent()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:tesla.FunctionEvent)
}

void FunctionEvent::InitAsDefaultInstance() {
  function_ = const_cast< ::tesla::FunctionRef*>(&::tesla::FunctionRef::default_instance());
  expectedreturnvalue_ = const_cast< ::tesla::Argument*>(&::tesla::Argument::default_instance());
  receiver_ = const_cast< ::tesla::Argument*>(&::tesla::Argument::default_instance());
}

FunctionEvent::FunctionEvent(const FunctionEvent& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:tesla.FunctionEvent)
}

void FunctionEvent::SharedCtor() {
  _cached_size_ = 0;
  function_ = NULL;
  direction_ = 1;
  context_ = 1;
  expectedreturnvalue_ = NULL;
  strict_ = true;
  kind_ = 1;
  receiver_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FunctionEvent::~FunctionEvent() {
  // @@protoc_insertion_point(destructor:tesla.FunctionEvent)
  SharedDtor();
}

void FunctionEvent::SharedDtor() {
  if (this != default_instance_) {
    delete function_;
    delete expectedreturnvalue_;
    delete receiver_;
  }
}

void FunctionEvent::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FunctionEvent::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FunctionEvent_descriptor_;
}

const FunctionEvent& FunctionEvent::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tesla_2eproto();
  return *default_instance_;
}

FunctionEvent* FunctionEvent::default_instance_ = NULL;

FunctionEvent* FunctionEvent::New() const {
  return new FunctionEvent;
}

void FunctionEvent::Clear() {
  if (_has_bits_[0 / 32] & 247) {
    if (has_function()) {
      if (function_ != NULL) function_->::tesla::FunctionRef::Clear();
    }
    direction_ = 1;
    context_ = 1;
    if (has_expectedreturnvalue()) {
      if (expectedreturnvalue_ != NULL) expectedreturnvalue_->::tesla::Argument::Clear();
    }
    strict_ = true;
    kind_ = 1;
    if (has_receiver()) {
      if (receiver_ != NULL) receiver_->::tesla::Argument::Clear();
    }
  }
  argument_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FunctionEvent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tesla.FunctionEvent)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .tesla.FunctionRef function = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_function()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_direction;
        break;
      }

      // optional .tesla.FunctionEvent.Direction direction = 2;
      case 2: {
        if (tag == 16) {
         parse_direction:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::tesla::FunctionEvent_Direction_IsValid(value)) {
            set_direction(static_cast< ::tesla::FunctionEvent_Direction >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_context;
        break;
      }

      // optional .tesla.FunctionEvent.CallContext context = 3;
      case 3: {
        if (tag == 24) {
         parse_context:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::tesla::FunctionEvent_CallContext_IsValid(value)) {
            set_context(static_cast< ::tesla::FunctionEvent_CallContext >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_argument;
        break;
      }

      // repeated .tesla.Argument argument = 4;
      case 4: {
        if (tag == 34) {
         parse_argument:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_argument()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_argument;
        if (input->ExpectTag(42)) goto parse_expectedReturnValue;
        break;
      }

      // optional .tesla.Argument expectedReturnValue = 5;
      case 5: {
        if (tag == 42) {
         parse_expectedReturnValue:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_expectedreturnvalue()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_strict;
        break;
      }

      // optional bool strict = 6 [default = true];
      case 6: {
        if (tag == 48) {
         parse_strict:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &strict_)));
          set_has_strict();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_kind;
        break;
      }

      // optional .tesla.FunctionEvent.CallKind kind = 7 [default = CCall];
      case 7: {
        if (tag == 56) {
         parse_kind:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::tesla::FunctionEvent_CallKind_IsValid(value)) {
            set_kind(static_cast< ::tesla::FunctionEvent_CallKind >(value));
          } else {
            mutable_unknown_fields()->AddVarint(7, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_receiver;
        break;
      }

      // optional .tesla.Argument receiver = 8;
      case 8: {
        if (tag == 66) {
         parse_receiver:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_receiver()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tesla.FunctionEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tesla.FunctionEvent)
  return false;
#undef DO_
}

void FunctionEvent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tesla.FunctionEvent)
  // required .tesla.FunctionRef function = 1;
  if (has_function()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->function(), output);
  }

  // optional .tesla.FunctionEvent.Direction direction = 2;
  if (has_direction()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->direction(), output);
  }

  // optional .tesla.FunctionEvent.CallContext context = 3;
  if (has_context()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->context(), output);
  }

  // repeated .tesla.Argument argument = 4;
  for (int i = 0; i < this->argument_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->argument(i), output);
  }

  // optional .tesla.Argument expectedReturnValue = 5;
  if (has_expectedreturnvalue()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->expectedreturnvalue(), output);
  }

  // optional bool strict = 6 [default = true];
  if (has_strict()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->strict(), output);
  }

  // optional .tesla.FunctionEvent.CallKind kind = 7 [default = CCall];
  if (has_kind()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->kind(), output);
  }

  // optional .tesla.Argument receiver = 8;
  if (has_receiver()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->receiver(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tesla.FunctionEvent)
}

::google::protobuf::uint8* FunctionEvent::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:tesla.FunctionEvent)
  // required .tesla.FunctionRef function = 1;
  if (has_function()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->function(), target);
  }

  // optional .tesla.FunctionEvent.Direction direction = 2;
  if (has_direction()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->direction(), target);
  }

  // optional .tesla.FunctionEvent.CallContext context = 3;
  if (has_context()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->context(), target);
  }

  // repeated .tesla.Argument argument = 4;
  for (int i = 0; i < this->argument_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->argument(i), target);
  }

  // optional .tesla.Argument expectedReturnValue = 5;
  if (has_expectedreturnvalue()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->expectedreturnvalue(), target);
  }

  // optional bool strict = 6 [default = true];
  if (has_strict()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->strict(), target);
  }

  // optional .tesla.FunctionEvent.CallKind kind = 7 [default = CCall];
  if (has_kind()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      7, this->kind(), target);
  }

  // optional .tesla.Argument receiver = 8;
  if (has_receiver()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->receiver(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tesla.FunctionEvent)
  return target;
}

int FunctionEvent::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .tesla.FunctionRef function = 1;
    if (has_function()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->function());
    }

    // optional .tesla.FunctionEvent.Direction direction = 2;
    if (has_direction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->direction());
    }

    // optional .tesla.FunctionEvent.CallContext context = 3;
    if (has_context()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->context());
    }

    // optional .tesla.Argument expectedReturnValue = 5;
    if (has_expectedreturnvalue()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->expectedreturnvalue());
    }

    // optional bool strict = 6 [default = true];
    if (has_strict()) {
      total_size += 1 + 1;
    }

    // optional .tesla.FunctionEvent.CallKind kind = 7 [default = CCall];
    if (has_kind()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->kind());
    }

    // optional .tesla.Argument receiver = 8;
    if (has_receiver()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->receiver());
    }

  }
  // repeated .tesla.Argument argument = 4;
  total_size += 1 * this->argument_size();
  for (int i = 0; i < this->argument_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->argument(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FunctionEvent::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FunctionEvent* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FunctionEvent*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FunctionEvent::MergeFrom(const FunctionEvent& from) {
  GOOGLE_CHECK_NE(&from, this);
  argument_.MergeFrom(from.argument_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_function()) {
      mutable_function()->::tesla::FunctionRef::MergeFrom(from.function());
    }
    if (from.has_direction()) {
      set_direction(from.direction());
    }
    if (from.has_context()) {
      set_context(from.context());
    }
    if (from.has_expectedreturnvalue()) {
      mutable_expectedreturnvalue()->::tesla::Argument::MergeFrom(from.expectedreturnvalue());
    }
    if (from.has_strict()) {
      set_strict(from.strict());
    }
    if (from.has_kind()) {
      set_kind(from.kind());
    }
    if (from.has_receiver()) {
      mutable_receiver()->::tesla::Argument::MergeFrom(from.receiver());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FunctionEvent::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FunctionEvent::CopyFrom(const FunctionEvent& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FunctionEvent::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_function()) {
    if (!this->function().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->argument())) return false;
  if (has_expectedreturnvalue()) {
    if (!this->expectedreturnvalue().IsInitialized()) return false;
  }
  if (has_receiver()) {
    if (!this->receiver().IsInitialized()) return false;
  }
  return true;
}

void FunctionEvent::Swap(FunctionEvent* other) {
  if (other != this) {
    std::swap(function_, other->function_);
    std::swap(direction_, other->direction_);
    std::swap(context_, other->context_);
    argument_.Swap(&other->argument_);
    std::swap(expectedreturnvalue_, other->expectedreturnvalue_);
    std::swap(strict_, other->strict_);
    std::swap(kind_, other->kind_);
    std::swap(receiver_, other->receiver_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FunctionEvent::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FunctionEvent_descriptor_;
  metadata.reflection = FunctionEvent_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FunctionRef::kNameFieldNumber;
#endif  // !_MSC_VER

FunctionRef::FunctionRef()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:tesla.FunctionRef)
}

void FunctionRef::InitAsDefaultInstance() {
}

FunctionRef::FunctionRef(const FunctionRef& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:tesla.FunctionRef)
}

void FunctionRef::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FunctionRef::~FunctionRef() {
  // @@protoc_insertion_point(destructor:tesla.FunctionRef)
  SharedDtor();
}

void FunctionRef::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (this != default_instance_) {
  }
}

void FunctionRef::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FunctionRef::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FunctionRef_descriptor_;
}

const FunctionRef& FunctionRef::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tesla_2eproto();
  return *default_instance_;
}

FunctionRef* FunctionRef::default_instance_ = NULL;

FunctionRef* FunctionRef::New() const {
  return new FunctionRef;
}

void FunctionRef::Clear() {
  if (has_name()) {
    if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      name_->clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FunctionRef::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tesla.FunctionRef)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tesla.FunctionRef)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tesla.FunctionRef)
  return false;
#undef DO_
}

void FunctionRef::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tesla.FunctionRef)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tesla.FunctionRef)
}

::google::protobuf::uint8* FunctionRef::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:tesla.FunctionRef)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tesla.FunctionRef)
  return target;
}

int FunctionRef::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FunctionRef::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FunctionRef* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FunctionRef*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FunctionRef::MergeFrom(const FunctionRef& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FunctionRef::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FunctionRef::CopyFrom(const FunctionRef& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FunctionRef::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void FunctionRef::Swap(FunctionRef* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FunctionRef::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FunctionRef_descriptor_;
  metadata.reflection = FunctionRef_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* FieldAssignment_AssignType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FieldAssignment_AssignType_descriptor_;
}
bool FieldAssignment_AssignType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const FieldAssignment_AssignType FieldAssignment::SimpleAssign;
const FieldAssignment_AssignType FieldAssignment::PlusEqual;
const FieldAssignment_AssignType FieldAssignment::MinusEqual;
const FieldAssignment_AssignType FieldAssignment::AssignType_MIN;
const FieldAssignment_AssignType FieldAssignment::AssignType_MAX;
const int FieldAssignment::AssignType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int FieldAssignment::kFieldFieldNumber;
const int FieldAssignment::kOperationFieldNumber;
const int FieldAssignment::kValueFieldNumber;
const int FieldAssignment::kStrictFieldNumber;
#endif  // !_MSC_VER

FieldAssignment::FieldAssignment()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:tesla.FieldAssignment)
}

void FieldAssignment::InitAsDefaultInstance() {
  field_ = const_cast< ::tesla::StructField*>(&::tesla::StructField::default_instance());
  value_ = const_cast< ::tesla::Argument*>(&::tesla::Argument::default_instance());
}

FieldAssignment::FieldAssignment(const FieldAssignment& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:tesla.FieldAssignment)
}

void FieldAssignment::SharedCtor() {
  _cached_size_ = 0;
  field_ = NULL;
  operation_ = 1;
  value_ = NULL;
  strict_ = true;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FieldAssignment::~FieldAssignment() {
  // @@protoc_insertion_point(destructor:tesla.FieldAssignment)
  SharedDtor();
}

void FieldAssignment::SharedDtor() {
  if (this != default_instance_) {
    delete field_;
    delete value_;
  }
}

void FieldAssignment::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FieldAssignment::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FieldAssignment_descriptor_;
}

const FieldAssignment& FieldAssignment::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tesla_2eproto();
  return *default_instance_;
}

FieldAssignment* FieldAssignment::default_instance_ = NULL;

FieldAssignment* FieldAssignment::New() const {
  return new FieldAssignment;
}

void FieldAssignment::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    if (has_field()) {
      if (field_ != NULL) field_->::tesla::StructField::Clear();
    }
    operation_ = 1;
    if (has_value()) {
      if (value_ != NULL) value_->::tesla::Argument::Clear();
    }
    strict_ = true;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FieldAssignment::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tesla.FieldAssignment)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .tesla.FieldAssignment.AssignType operation = 4;
      case 4: {
        if (tag == 32) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::tesla::FieldAssignment_AssignType_IsValid(value)) {
            set_operation(static_cast< ::tesla::FieldAssignment_AssignType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_value;
        break;
      }

      // required .tesla.Argument value = 5;
      case 5: {
        if (tag == 42) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_strict;
        break;
      }

      // optional bool strict = 7 [default = true];
      case 7: {
        if (tag == 56) {
         parse_strict:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &strict_)));
          set_has_strict();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_field;
        break;
      }

      // required .tesla.StructField field = 8;
      case 8: {
        if (tag == 66) {
         parse_field:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_field()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tesla.FieldAssignment)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tesla.FieldAssignment)
  return false;
#undef DO_
}

void FieldAssignment::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tesla.FieldAssignment)
  // required .tesla.FieldAssignment.AssignType operation = 4;
  if (has_operation()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->operation(), output);
  }

  // required .tesla.Argument value = 5;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->value(), output);
  }

  // optional bool strict = 7 [default = true];
  if (has_strict()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->strict(), output);
  }

  // required .tesla.StructField field = 8;
  if (has_field()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->field(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tesla.FieldAssignment)
}

::google::protobuf::uint8* FieldAssignment::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:tesla.FieldAssignment)
  // required .tesla.FieldAssignment.AssignType operation = 4;
  if (has_operation()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->operation(), target);
  }

  // required .tesla.Argument value = 5;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->value(), target);
  }

  // optional bool strict = 7 [default = true];
  if (has_strict()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->strict(), target);
  }

  // required .tesla.StructField field = 8;
  if (has_field()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->field(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tesla.FieldAssignment)
  return target;
}

int FieldAssignment::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .tesla.StructField field = 8;
    if (has_field()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->field());
    }

    // required .tesla.FieldAssignment.AssignType operation = 4;
    if (has_operation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->operation());
    }

    // required .tesla.Argument value = 5;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->value());
    }

    // optional bool strict = 7 [default = true];
    if (has_strict()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FieldAssignment::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FieldAssignment* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FieldAssignment*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FieldAssignment::MergeFrom(const FieldAssignment& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_field()) {
      mutable_field()->::tesla::StructField::MergeFrom(from.field());
    }
    if (from.has_operation()) {
      set_operation(from.operation());
    }
    if (from.has_value()) {
      mutable_value()->::tesla::Argument::MergeFrom(from.value());
    }
    if (from.has_strict()) {
      set_strict(from.strict());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FieldAssignment::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FieldAssignment::CopyFrom(const FieldAssignment& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FieldAssignment::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_field()) {
    if (!this->field().IsInitialized()) return false;
  }
  if (has_value()) {
    if (!this->value().IsInitialized()) return false;
  }
  return true;
}

void FieldAssignment::Swap(FieldAssignment* other) {
  if (other != this) {
    std::swap(field_, other->field_);
    std::swap(operation_, other->operation_);
    std::swap(value_, other->value_);
    std::swap(strict_, other->strict_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FieldAssignment::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FieldAssignment_descriptor_;
  metadata.reflection = FieldAssignment_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int StructField::kTypeFieldNumber;
const int StructField::kBaseFieldNumber;
const int StructField::kNameFieldNumber;
const int StructField::kIndexFieldNumber;
#endif  // !_MSC_VER

StructField::StructField()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:tesla.StructField)
}

void StructField::InitAsDefaultInstance() {
  base_ = const_cast< ::tesla::Argument*>(&::tesla::Argument::default_instance());
}

StructField::StructField(const StructField& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:tesla.StructField)
}

void StructField::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  base_ = NULL;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  index_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StructField::~StructField() {
  // @@protoc_insertion_point(destructor:tesla.StructField)
  SharedDtor();
}

void StructField::SharedDtor() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (this != default_instance_) {
    delete base_;
  }
}

void StructField::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StructField::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StructField_descriptor_;
}

const StructField& StructField::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tesla_2eproto();
  return *default_instance_;
}

StructField* StructField::default_instance_ = NULL;

StructField* StructField::New() const {
  return new StructField;
}

void StructField::Clear() {
  if (_has_bits_[0 / 32] & 15) {
    if (has_type()) {
      if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        type_->clear();
      }
    }
    if (has_base()) {
      if (base_ != NULL) base_->::tesla::Argument::Clear();
    }
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    index_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool StructField::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tesla.StructField)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string type = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->type().data(), this->type().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "type");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_base;
        break;
      }

      // required .tesla.Argument base = 2;
      case 2: {
        if (tag == 18) {
         parse_base:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_base()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_name;
        break;
      }

      // required string name = 3;
      case 3: {
        if (tag == 26) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_index;
        break;
      }

      // required int32 index = 4;
      case 4: {
        if (tag == 32) {
         parse_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tesla.StructField)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tesla.StructField)
  return false;
#undef DO_
}

void StructField::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tesla.StructField)
  // required string type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->type(), output);
  }

  // required .tesla.Argument base = 2;
  if (has_base()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->base(), output);
  }

  // required string name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->name(), output);
  }

  // required int32 index = 4;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->index(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tesla.StructField)
}

::google::protobuf::uint8* StructField::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:tesla.StructField)
  // required string type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "type");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->type(), target);
  }

  // required .tesla.Argument base = 2;
  if (has_base()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->base(), target);
  }

  // required string name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->name(), target);
  }

  // required int32 index = 4;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->index(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tesla.StructField)
  return target;
}

int StructField::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->type());
    }

    // required .tesla.Argument base = 2;
    if (has_base()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->base());
    }

    // required string name = 3;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required int32 index = 4;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->index());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StructField::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const StructField* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const StructField*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void StructField::MergeFrom(const StructField& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_base()) {
      mutable_base()->::tesla::Argument::MergeFrom(from.base());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_index()) {
      set_index(from.index());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void StructField::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StructField::CopyFrom(const StructField& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StructField::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_base()) {
    if (!this->base().IsInitialized()) return false;
  }
  return true;
}

void StructField::Swap(StructField* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(base_, other->base_);
    std::swap(name_, other->name_);
    std::swap(index_, other->index_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata StructField::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StructField_descriptor_;
  metadata.reflection = StructField_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Argument_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Argument_Type_descriptor_;
}
bool Argument_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Argument_Type Argument::Constant;
const Argument_Type Argument::Variable;
const Argument_Type Argument::Any;
const Argument_Type Argument::Indirect;
const Argument_Type Argument::Field;
const Argument_Type Argument::Type_MIN;
const Argument_Type Argument::Type_MAX;
const int Argument::Type_ARRAYSIZE;
#endif  // _MSC_VER
const ::google::protobuf::EnumDescriptor* Argument_MatchType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Argument_MatchType_descriptor_;
}
bool Argument_MatchType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Argument_MatchType Argument::Exact;
const Argument_MatchType Argument::Flags;
const Argument_MatchType Argument::Mask;
const Argument_MatchType Argument::MatchType_MIN;
const Argument_MatchType Argument::MatchType_MAX;
const int Argument::MatchType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Argument::kTypeFieldNumber;
const int Argument::kIndexFieldNumber;
const int Argument::kNameFieldNumber;
const int Argument::kFreeFieldNumber;
const int Argument::kValueFieldNumber;
const int Argument::kConstantMatchFieldNumber;
const int Argument::kIndirectionFieldNumber;
const int Argument::kFieldFieldNumber;
#endif  // !_MSC_VER

Argument::Argument()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:tesla.Argument)
}

void Argument::InitAsDefaultInstance() {
  indirection_ = const_cast< ::tesla::Argument*>(&::tesla::Argument::default_instance());
  field_ = const_cast< ::tesla::StructField*>(&::tesla::StructField::default_instance());
}

Argument::Argument(const Argument& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:tesla.Argument)
}

void Argument::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  type_ = 1;
  index_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  free_ = false;
  value_ = GOOGLE_LONGLONG(0);
  constantmatch_ = 1;
  indirection_ = NULL;
  field_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Argument::~Argument() {
  // @@protoc_insertion_point(destructor:tesla.Argument)
  SharedDtor();
}

void Argument::SharedDtor() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (this != default_instance_) {
    delete indirection_;
    delete field_;
  }
}

void Argument::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Argument::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Argument_descriptor_;
}

const Argument& Argument::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_tesla_2eproto();
  return *default_instance_;
}

Argument* Argument::default_instance_ = NULL;

Argument* Argument::New() const {
  return new Argument;
}

void Argument::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Argument*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(value_, free_);
    type_ = 1;
    index_ = 0;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        name_->clear();
      }
    }
    constantmatch_ = 1;
    if (has_indirection()) {
      if (indirection_ != NULL) indirection_->::tesla::Argument::Clear();
    }
    if (has_field()) {
      if (field_ != NULL) field_->::tesla::StructField::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Argument::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tesla.Argument)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .tesla.Argument.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::tesla::Argument_Type_IsValid(value)) {
            set_type(static_cast< ::tesla::Argument_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_index;
        break;
      }

      // optional int32 index = 2;
      case 2: {
        if (tag == 16) {
         parse_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_name;
        break;
      }

      // optional string name = 3;
      case 3: {
        if (tag == 26) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_value;
        break;
      }

      // optional int64 value = 5;
      case 5: {
        if (tag == 40) {
         parse_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_constantMatch;
        break;
      }

      // optional .tesla.Argument.MatchType constantMatch = 6 [default = Exact];
      case 6: {
        if (tag == 48) {
         parse_constantMatch:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::tesla::Argument_MatchType_IsValid(value)) {
            set_constantmatch(static_cast< ::tesla::Argument_MatchType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_indirection;
        break;
      }

      // optional .tesla.Argument indirection = 7;
      case 7: {
        if (tag == 58) {
         parse_indirection:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_indirection()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_field;
        break;
      }

      // optional .tesla.StructField field = 8;
      case 8: {
        if (tag == 66) {
         parse_field:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_field()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_free;
        break;
      }

      // optional bool free = 9 [default = false];
      case 9: {
        if (tag == 72) {
         parse_free:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &free_)));
          set_has_free();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tesla.Argument)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tesla.Argument)
  return false;
#undef DO_
}

void Argument::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tesla.Argument)
  // required .tesla.Argument.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional int32 index = 2;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->index(), output);
  }

  // optional string name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->name(), output);
  }

  // optional int64 value = 5;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->value(), output);
  }

  // optional .tesla.Argument.MatchType constantMatch = 6 [default = Exact];
  if (has_constantmatch()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->constantmatch(), output);
  }

  // optional .tesla.Argument indirection = 7;
  if (has_indirection()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->indirection(), output);
  }

  // optional .tesla.StructField field = 8;
  if (has_field()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->field(), output);
  }

  // optional bool free = 9 [default = false];
  if (has_free()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->free(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tesla.Argument)
}

::google::protobuf::uint8* Argument::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:tesla.Argument)
  // required .tesla.Argument.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional int32 index = 2;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->index(), target);
  }

  // optional string name = 3;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->name(), target);
  }

  // optional int64 value = 5;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(5, this->value(), target);
  }

  // optional .tesla.Argument.MatchType constantMatch = 6 [default = Exact];
  if (has_constantmatch()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->constantmatch(), target);
  }

  // optional .tesla.Argument indirection = 7;
  if (has_indirection()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->indirection(), target);
  }

  // optional .tesla.StructField field = 8;
  if (has_field()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->field(), target);
  }

  // optional bool free = 9 [default = false];
  if (has_free()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(9, this->free(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tesla.Argument)
  return target;
}

int Argument::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .tesla.Argument.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional int32 index = 2;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->index());
    }

    // optional string name = 3;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional bool free = 9 [default = false];
    if (has_free()) {
      total_size += 1 + 1;
    }

    // optional int64 value = 5;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->value());
    }

    // optional .tesla.Argument.MatchType constantMatch = 6 [default = Exact];
    if (has_constantmatch()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->constantmatch());
    }

    // optional .tesla.Argument indirection = 7;
    if (has_indirection()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->indirection());
    }

    // optional .tesla.StructField field = 8;
    if (has_field()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->field());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Argument::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Argument* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Argument*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Argument::MergeFrom(const Argument& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_free()) {
      set_free(from.free());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
    if (from.has_constantmatch()) {
      set_constantmatch(from.constantmatch());
    }
    if (from.has_indirection()) {
      mutable_indirection()->::tesla::Argument::MergeFrom(from.indirection());
    }
    if (from.has_field()) {
      mutable_field()->::tesla::StructField::MergeFrom(from.field());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Argument::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Argument::CopyFrom(const Argument& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Argument::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_indirection()) {
    if (!this->indirection().IsInitialized()) return false;
  }
  if (has_field()) {
    if (!this->field().IsInitialized()) return false;
  }
  return true;
}

void Argument::Swap(Argument* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(index_, other->index_);
    std::swap(name_, other->name_);
    std::swap(free_, other->free_);
    std::swap(value_, other->value_);
    std::swap(constantmatch_, other->constantmatch_);
    std::swap(indirection_, other->indirection_);
    std::swap(field_, other->field_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Argument::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Argument_descriptor_;
  metadata.reflection = Argument_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace tesla

// @@protoc_insertion_point(global_scope)
